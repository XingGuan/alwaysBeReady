### `CSS`层叠上下文   

> 你可以把浏览器网页想象成一个三维空间，不仅有长和宽（X轴和Y轴），还有深度（z轴）。元素在这个`Z`轴上的排列顺序，就决定了谁在上面遮盖谁。   

#### 层叠上下文   
> 定义：层叠上下文是一个三维概念，它是一块独立的渲染区域，内部有一套自己的层叠规则。这个区域内的元素与外部元素比较时，会作为一个整体来考虑。  

比如：想象一栋大楼  
+ 整栋大楼就是一个**根层叠上下文**（由`<html>`元素创建）。  
+ 大楼里的每一个**房间**就是一个新的层叠上下文。  
+ 房间里的家具（元素）可以随意摆放高低（`z-index`）,但无论家具多高，它都不可能高过另一个**更高楼层房间里的家具**。   

创建条件：一个元素在满足以下条件之一时，会创建自己的层叠上下文：  
1.文档的根元素(`html`)：天生的"大楼"。   
2.定位元素且`z-index`值不为`auto`:如`position:absolute/relative/fixed/sticky`并设置了`z-index:0`;或任何其他整数值。
3.`Flex/Grid`**容器的子项目**`z-index`不为`auto`：即使这个子项没有设置`position`属性！   
4.`opacity`值小于1。  
5.`transform`值不为`none`。   
6.`filter`值不为`none`。  
7.还有其他属性如`will-change`,`contain`,`mix-blend-mods`等。   

> 关键属性：层叠上下文是独立的。一个层叠上下文内元素的`z-index`值只在这个"小房间"内部有效。它要跟外部元素比较时，是以整个房间的身份去比的。  

2.`z-index`  
> 定义：`z-index`是一个用于在同一个层叠上下文内控制子元素`Z轴`顺序的`CSS`属性。  

重要特性：  
**仅对定位元素生效**：即`position`值为`relative`,`absolute`,`fixed`,`sticky`的元素。`Flex/Grid`子项是例外。  
+ 它的比较范围受限于其所在的层叠上下文。它不能跨"房间"比较。   

取值：  
+ `auto`：默认值。不会创建新的层叠上下文。  
+ `<integer>`：整数值(正、负、0均可)。数值越大，元素在`Z`轴上就越靠前(离用户越近)。   

#### 层叠顺序规则（同一上下文内）
即使没有设置`z-index`,元素也有默认的层叠顺序。在同一个层叠上下文中，从后到前（从底到顶）的顺序是：  
    1.层叠上下文的根元素 
    2.`z-index`为**负**的定位元素（及其子上下文）  
    3.块级元素（如 `div、p`）
    4.浮动元素
    5.内联元素（如文本、`span`）
    6.`z-index`为`auto`或`0`的定位元素（**注意：`z-index:0`**会创建层叠上下文，而`z-index:auto`不会）  
    7.`z-index`为**正**的定位元素（及其子上下文）  
**简单记法：**负`z-index`<普通流元素（块、内联、浮动）< `auto/0` < 正`z-index`  

### 什么情况下`z-index`会不生效  
通常原因有以下几种：  
1.父级没有创建层叠上下文（!最常见）  
问题描述： 
你给一个元素设置了很大的 `z-index` (例如 9999)，但它依然被另一个元素遮盖。这是因为它的父元素没有创建层叠上下文，导致它的 `z-index` 是在和“叔叔伯伯”（父元素的兄弟）辈的元素比较，而不是和“堂兄弟”（你以为的那个遮盖它的元素）比较。  
**根本原因**：那个遮盖它的元素，其父元素创建了一个层叠上下文，并且这个父元素的层叠顺序比你当前元素所在的层叠顺序更高。  

**解决方案：**  
+ 为你当前元素的父元素创建一个层叠上下文，并设置一个合适的`z-index`。  
+ 常用方法：给父元素加`position:relative`和`z-index:0`(或其他需要的值)  

**代码示例：**  
```html
<div class="parent-a"> <!-- 这个div创建了层叠上下文 -->
  <div class="child-a">我被显示了</div>
</div>

<div class="parent-b"> <!-- 这个div没有创建层叠上下文 -->
  <div class="child-b">我z-index:9999也没用</div>
</div>
```  
```css
.parent-a {
  position: relative;
  z-index: 1; /* 创建了层叠上下文，并且顺序更高 */
}

.child-b {
  position: relative;
  z-index: 9999; /* 无效！因为 parent-b 不是层叠上下文，child-b 实际上是在和 parent-a 比较 */
}
```  
在这个例子中，`.child-b` 的 `z-index: 9999` 是在和 `.parent-a` 的 `z-index: 1` 比较，由于 `.parent-a` 是一个完整的层叠上下文，它内部的整个“世界”都比外部的 `.child-b` 层级高，所以 `.child-a` 永远在 `.child-b` 上面。

2.元素不是定位元素   
问题描述：给一个`position:static`(默认定位)的元素设置`z-index`。  
原因：`z-index`只对定位元素（`relative,absolute,fixed,sticky`）生效（`Flex/Grid`子项除外）。  
解决方案：给元素加上`position`属性并设置为非`static`的值。  

3.被更高级的层叠上下文"封印"。  

问题描述：你的元素在一个层叠上下文`A（z-index: 10）`内，而另一个元素在层叠上下文`B（z-index: 11）`内。那么，无论你在A内部怎么调整 `z-index`，`A`内部的任何元素都不可能高过B内部的元素。就像一楼的吊灯（`z-index`再高）也不可能高过二楼的地板。

**解决方案：**你需要提升整个"房间"(层叠上下文`A`)的层级，即调整`A`的`z-index`,使其大于`B`的`z-index`。

4.浏览器兼容性或特殊属性   
+ 非常老的浏览器可能存在`z-index`的`bug`。  
+ 某些`CSS`属性如`overflow:hidden`可能会裁掉超出的部分，看起来像是`z-index`失效，其实是元素被裁剪了。  

### 总结与排查技巧   
当遇到`z-index`不生效时，请按以下步骤排查：   
1.检查定位：元素是否设置了`position`为非`static`的值？(`Flex/Grid`子项可跳过此步)。 
2.**向上排查父级**：这是最关键的一步！从当前元素开始，**逐级向上检查其父元素**，直到`<html>`。看看是哪个元素创建了层叠上下文。通常问题就出在：**你想比较两个元素，不在同一个层叠上下文中**。  
    + 在浏览器开发者工具中，你可以通过检查元素，看它的"`Computed`"样式里是否有`transform`，`opacity`,`filter`等属性，或者是否有`position`和`z-index`组合，这些都可能创建了层叠上下文。
3.比较层级：确认了所在的层叠上下文后，再去比较这些上下文本身的层级顺序。   


