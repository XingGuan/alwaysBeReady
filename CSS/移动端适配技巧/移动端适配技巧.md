### 移动端适配技巧   
#### 视口设置  
`<meta name="viewport" content="width=device-width,initial-scale=1" >`   
> 这段代码是响应式网页设计的基石，它的作用是告诉浏览器如何控制页面尺寸和缩放比例，使其在移动设备上能够正确显示。  

我们可以把它拆解开来理解：
#### 1.没有这个标签时会发生什么？  
在没有这个`<meta viewport>`标签的情况下，移动设备浏览器（如`iPhone`的`Safari`或安卓的`Chrome`）会默认地**假设你的网页是为比手机屏幕宽的多的桌面显示器设计的**。  
为了能完整地显示整个桌面版页面，移动浏览器会使用一个**虚拟的窗口**（通常称为"布局视口"，默认宽度一般为`980px`）来渲染页面，然后将这个渲染结果缩小到手机屏幕的物理宽度内。  
**结果就是**：网页上的文字和元素变得非常小，用户必须手动放大或横向滚动才能阅读内容，体验极差。   
2.这段代码的作用：逐个解析   
`<meta name="viewport" content="width=device-width,initial-scale=1">`
+ `meta`这是一个元数据标签，提供关于`HTML`文档本身的信息，不会直接显示在页面上。  
+ `name=viewport`：指定这个元数据的类型是用于**控制视口（`viewport`）**的。视口就是用户在屏幕上能看到网页内容的区域。  
+ `content="……"`：里面包含具体的指令，用逗号分隔。
> 指令解析：  
+ `width=device-width`  
  + 作用：这是最重要的指令。它告诉浏览器："请将布局视口的宽度设置为设备屏幕的理想视口宽度（比如`iphone 12`是`390px`,不同设备不同），而不是那个默认的`980px`"。
  + 效果：从此，你的`CSS`样式（例如 `div { width: 100% }`）中的宽度计算基准就成了设备屏幕的宽度。一个宽度为`100%`的元素会正好撑满屏幕宽度，而不是`980px`的宽度。   
+ `initial-scale=1`   
  + **作用**：**设置页面的初始缩放比例为1（即`100%`，不缩放）**。  
  + **效果**：确保页面在加载时以`1:1`的比例呈现，不会被意外放大或缩小。它通常也会帮助浏览器将视口宽度设置为`device-width`。   

> **两者结合的效果就是**：浏览器会以设备的理想视口宽度作为基准来渲染页面，并且不进行缩放。这使得你的媒体查询（`Media Queries`）和响应式布局能够正常工作，网页内容（文字、布局）能以符合移动设备阅读习惯的方式呈现。  

### 总结类比  
    你可以把它想象成：  
    + 没有**viewport**设置：就像你拿着一张小照片（自己的网页），站得很远去看（移动浏览器的默认行为），照片整体能看清，但细节很小。
    + 有**viewport**设置：就像你把照片拿到眼前合适的位置（`width=device-width`）,并且不使用放大镜（`initial-scale=1`）,照片的内容大小正合适，清晰易读。

#### 其他常用指令（扩展）
 除了上面两个核心指令， `content`里面还可以添加其他指令： 
      `user-scalable=no`   /* 禁止用户缩放页面（**谨慎使用**，会损害可访问性） */
      `maximum-scale=1.5`  /* 允许用户缩放的最大比例 */
      `minimum-scale=0.5`   /* 允许用户缩放的最小比例 */
      `viewport-fit=cover`  /* 常用于全面屏设备或`WebApp`,让网页内容覆盖整个屏幕，包括"刘海"区域 */  
      
> **最佳实践**：对于绝大多数响应式网站，你只需要使用`width=device-width`,`initial-scale=1`这个设置即可。它是现代移动端网页开发的标准配置。 


#### 处理`1px`边框  
##### 这个问题是怎么产生的
这个问题的核心根源在于：**`CSS`中的像素（`px`）是一个相对/逻辑单位**，它与设备物理像素之间有一个比例关系，这个比例由`devicePixelRadio`(**设备像素比，简称`DPR`决定**)。  
+ **`CSS`像素（`logical Pixel`）**：`Web`开发中使用的抽象单位，用于在浏览器中定义样式。  
+ **物理像素（`Physical Pixel`）**：设备屏幕上最小的物理显示单元，我们常说的手机分辨率（如 750x1334）指的就是物理像素。  
+ **设备像素比（`DPR`）**：公式：`DPR = 物理像素 / 逻辑像素`。它定义了在单个方向上，一个`CSS`像素需要由多少个物理像素来渲染。   
产生过程：  
1.理想情况（`DPR=1`）:在早期的非`Retina`屏幕上，1个`CSS`像素正好是由1个物理像素渲染，所以`border:1px solid black;`会呈现为清晰的1物理像素宽度的边框。
2.现实情况（`DPR>1`）:在高分辨率移动设备（如`iPhone`的`Retina`屏）上，`DPR`通常为2、3甚至更高。例如，`iPhone`的`DPR`为2或3.  
  + 这意味着，为了显示更细腻的内容（如文字、图标），**1个`CSS`像素实际上是由 `2*2` 或 `3*3` 个物理像素块来渲染的**。  
  + 当你写下`border:1px solid black;`时，`CSS`的意思是"给我一个1逻辑像素宽的边框"。  
  + 因此，最终在屏幕上呈现出来的边框**实际物理宽度是设计期望的2倍**（`DPR=2时`）或3倍（`DPR=3时`），视觉上就会显示"粗"和"模糊",与设计稿不符。   

> 简单总结：问题是的本质是`1 CSS像素`在高清屏上被多个物理像素渲染，导致实际显示变粗。

##### 怎么解决呢？  
> 解决思路非常明确：想办法让边框的`CSS`逻辑像素小于`1px`,这样在高`DPR`设备上渲染时，乘以`DPR`后，其物理像素宽度正好接近或等于1。   

以下是几种主流且常用的解决方案：  
##### 方案1：伪元素 + `CSS3` `scale`缩放（最推荐、最灵活）   
这是目前最通用、兼容性最好的方案。原理是使用元素的伪元素（`:before`、`:after`）创建一条边框，然后通过`transform:scale()`将其缩小到所需尺寸。  
+ 实现步骤：  
+ 为需要边框的元素设置`position:relative`。  
+ 使用伪元素画一条"1px"的线。  
+ 根据设备的`DPR`,通过媒体查询`@media`,用`transform:scaleY()`或`transform:scaleX()`将这条线高度（或宽度）压缩到原来的`1/DPR`。  
示例代码：
```css
.border-1px {
  position: relative;
}

.border-1px::after {
  content: "";
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 1px; /* 初始高度是1px (CSS像素) */
  background-color: #ccc;
  transform-origin: 0 bottom; /* 设置缩放基点 */
}

/* 针对DPR=2的设备 */
@media (-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2) {
  .border-1px::after {
    transform: scaleY(0.5); /* 高度缩小为一半，在DPR=2的设备上，物理像素正好是 0.5 * 2 = 1px */
  }
}

/* 针对DPR=3的设备 */
@media (-webkit-min-device-pixel-ratio: 3), (min-device-pixel-ratio: 3) {
  .border-1px::after {
    transform: scaleY(0.333); /* 高度缩小为1/3，物理像素为 0.333 * 3 ≈ 1px */
  }
}
```  
优点：  
+ 兼容性好，可以灵活控制单边边框。  
+ 效果非常好，边框清晰。   
缺点：  
+ 代码量稍多，需要写媒体查询。  

##### 方案2：使用`viewport`进行缩放（简单粗暴）  
通过修改`<meta>`标签中的`viewport`的`initial-scale`值，直接改变布局视口（`layout viewport`）与理想视口（`ideal viewport`）的比例，从而让1个`CSS`像素等于1个**物理像素**。   
**实现步骤**：  
利用`JavaScript`动态获取设备的`DPR`,然后根据`DPR`改变`viewport`的缩放比例。   
```html   
<meta name="viewport" id="myViewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">  
<script>
  var viewport = document.getElementById('myViewport');  
  var dpr = window.devicePixelRadio || 1;   
  // 计算缩放比例 ：1/DPR  
  var scale = 1/`dpr`;  
  // 动态设置 viewport 的 initial-scale 和 maximum-scale
  viewport.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', user-scalable=0, viewport-fit=cover');

  // 同时，我们需要将布局视口的逻辑像素宽度调整为设备宽度 * DPR
  // 这样，我们写的CSS（例如元素的宽高）依然能保持和设计稿（通常是2倍图）一致的px值。
  var metaWidth = document.documentElement.clientWidth * dpr;
  document.documentElement.style.fontSize = metaWidth / 10 + 'px'; // 可选，常用于Rem适配

</script>
``` 
设置之后，你的`CSS`代码直接写`border:1px solid #ccc`;就是真正的一物理像素了。   
**优点**：  
+ 一劳永逸，整个页面都可以直接使用`1px`。  
+ 代码简单。  
**缺点**：  
+ 整个页面都被缩放了，布局可能会受到影响，需要配合`Rem`或`VW`等布局方案来整体调整页面布局和字体大小，否则所有元素的尺寸都会变小。   
+ 可能会引起一些第三方库的兼容性问题。   
##### 方案3：使用`border-image`或`background-image`(适用于简单边框)  
通过制作一个`1px`或`2px`高的线性渐变图片，作为边框的背景。   
```css
.border-image-1px{
  border-width: 0 0 1px 0; /* 只设置底部边框 */  
  border-image:url('data:image/png;base64,iVBOR...')  0 0 100% 0 stretch;
   /* 或者使用CSS渐变模拟 */
  background: linear-gradient(to bottom, transparent 50%, #ccc 50%) 0 100% repeat-x;
  background-size: 100% 1px; /* 关键：将背景高度压缩为1px */

}
```
优点：  
+ 实现相对简单。  
缺点：  
+ 无法实现圆角边框。  
+ 颜色固定，修改不便。 
+ `border-image`的兼容性一般，且代码不直观。 
 
##### 方案4：使用`box-shadow`模拟（适合简单需求）  
利用`CSS3`的`box-shadow`特性来模拟一个极细的"边框"。   
```css  
.box-shadow-1px{
   box-shadow: 0 -1px 0 0 #ccc,  /* 上边框 */
              1px 0 0 0 #ccc,   /* 右边框 */
              0 1px 0 0 #ccc,   /* 下边框 */
              -1px 0 0 0 #ccc;  /* 左边框 */
}
/* 或者只模拟单边 */
.bottom-shadow {
  box-shadow: 0 1px 1px -1px #ccc; /* 通过调整模糊半径和阴影扩散半径来实现 */
}
```  
**优点：**
+ 代码简单。   
**缺点：**
+ 模拟的边框是"阴影"，颜色和效果可能不如真实边框自然。   
+ 性能略差（虽然通常可以忽略不计）。 
#### 防止滚动穿透    
总结了几种主流且可靠的解决方案，从易到难。  
##### 核心原理  
> 所有方法的**核心原理**都是一样的：在浮层打开时，**阻止底层页面的默认的滚动行为**；在浮层关闭时，恢复该行为。   

##### 方法一：最简单粗暴的方法-固定`body`(适用于简单弹窗)    

##### 内部滚动边界穿透 
> **内部滚动边界穿透：在内部滚动元素滚动到顶部或底部时继续滑动，阻止默认行为。**

在浮层激活时，给`<body>`添加一个`CSS`类，将其设置为固定定位并禁止滚动。   
```css  
.body-no-scroll{
  position: fixed;  
  width:100%；
  height:100%;
  overflow:hidden;
}
```
```javascript
// 打开浮层时
function openModal(){
  document.body.classList.add('body-no-scroll');
}
// 关闭浮层时
function closeModal(){
  document.body.classList.remove('body-no-scroll');
  // ...其他关闭逻辑
}
```  
**优点**：  
+ 简单直接，代码量少。  
+ 兼容性好。  
**缺点**：  
+ **会导致页面跳回顶部**，因为`position:fixed`会使`body`脱离文档流，滚动位置会丢失。  
+ 如果需要保持当前滚动位置，需要额外用`JS`记录并复位，比较麻烦。   
**适用场景**：简单的、全屏的弹窗，不关心底层页面滚动位置的情况。   
##### 方法二：推荐方法 - 阻止触摸事件的默认行为（适用于内部可滚动的浮层）  
这是目前最常用且体验较好的方案。思路是：  
1.监听浮层容器上的`touchmove`事件。
2.如果浮层内容**已经滚动到顶部或底部**，则阻止默认行为（即阻止滚动传播到底层`body`）。  
3.否则，允许浮层内容正常滚动。   
```javascript
const modal = document.getElementById('my-modal');  
let startY = 0; // 记录触摸起始位置   
// 在打开浮层时添加事件监听   
modal.addEventListener('touchstart',function(e){
  startY = e.touches[0].clientY;
},{passive:true}); // 使用 passive 提高滚动性能   

modal.addEventListener('touchmove',function(e){
  const currentY = e.touches[0].clientY;  
  const delaY = currentY - startY;  

  // 检查浮层内容的滚动状态   
  const isScrolledToTop = modal.scrollTop <= 0;
  const isScrolledToBottom = modal.scrollTop + modal.clientHeight >= modal.scrollHeight;
  //关键逻辑：  
  // 1.如果是向下拉，并且已经在顶部，则阻止滚动（防止穿透）  
  // 2. 如果是向上推，并且已经在底部，则阻止滚动（防止穿透）  
  // 3. 其他情况允许浮层自身滚动   
  if(isScrolledToTop && delaY > 0 || isScrolledToBottom && delaY < 0){
    e.preventDefault(); // 阻止默认滚动行为
  }
  // 更新起始位置，为了能更准确的计算移动方向（可选）
 startY = currentY;
},{passive:false});// 注意：这里我们要用 preventDefault , passive 必须为 false
```    
**优点**：  
+ 完美解决了穿透问题，同时保留了浮层内容的流畅滚动。  
+ 不会影响页面滚动位置。  
**缺点**：  
+ 实现稍复杂，需要处理触摸事件和滚动边界判断。  
+ 需要注意`passive`事件的设置，否则`e.preventDefault()`可能无效。  

适用场景：绝大多数需要内部滚动的浮层，如聊天对话框、商品选择弹窗等。   

##### 方法三：`CSS`的`overflow-behavior`属性（现代浏览器首选）  
这是一个新的`CSS`属性，专门用于控制滚动到边界时的行为。
设置`overscroll-behavior:contain;`可以完美的阻止滚动链（`scroll-chaining`）,即滚动穿透。  
```css
    .modal-container {
        overscroll-behavior: contain; /* 关键属性 */
        overflow-y: auto; /* 确保元素可滚动 */  
        height: 80%; /* 或其他高度 */
    }
```  
**就这么简单！** 浏览器会自动处理边界情况，滚动到浮层顶部或底部时不会继续传播到底层页面。

**优点**：  
+ **极其简单**，一行代码解决问题。  
+ **性能好**，由浏览器原生实现。  
+ 无需任何 `JavaScript` 逻辑。   

**缺点**：  
+ **兼容性**：对**`IOS`的支持较晚**（从`IOS 16.4`开始才完整支持）。在较老的`IOS`设备上会失效。   

**适用场景**：  
+ 如果你的项目不需要支持老版本`IOS Safari`(例如是内部系统或主要用户使用较新设备)，这是**绝对的首选方案**。   
+ 可以作为渐进增强方案，在新浏览器上用`CSS`,在老浏览器上用方法二的`JS`作为回调（`Polyfill`）。   


##### 方法四：在浮层打开时临时设置`body`的`overflow:hidden`   
这与方法一类似，但不改变`position`。  
 + `CSS`  
```css
  .body-overflow-hidden {
      overflow: hidden;
      /* 可以加上 height: 100vh; 来防止一些安卓机上的细微抖动 */
  }
```
  ```JavaScript
  // 打开浮层时
  function openModal() {
      document.body.classList.add('body-overflow-hidden');
  }

  // 关闭浮层时
  function closeModal() {
      document.body.classList.remove('body-overflow-hidden');
  }
```
**优点**：
 + 不会像**position：fixed**那样导致页面跳回顶部。  
 **缺点**：  
 + 在`IOS Safari`上可能无效。`IOS`对`body`上的`overflow：hidden`处理一直有问题，通常需要将其应用到`<htmL>`和`<body>`两个元素上才能生效。  
```javascript
    function openModal(){
        const scrollTop = window.pageYOffset; // 先记录当前滚动位置  
        document.documentElement.classList.add('body-overflow-hidden');
        document.body.classList.add('body-overflow-hidden');
        // 强行将滚动位置设回原处，防止页面跳动  
        document.body.style.top = `- ${ scrollTop } px`;
    }
    function closeModal(){
        const scrollTop = parseInt(document.body.style.top || '0');
        document.documentElement.classList.remove('body-overflow-hidden');
        document.body.classList.remove('body-overflow-hidden');
        document.body.style.top = '';
        // 恢复滚动位置W
        window.scrollTo(0, Math.abs(scrollTop));
    }

```
这个改良版虽然解决了跳转问题，但变得相当复杂。  

#### 总结与建议  
  |方法|优点|缺点|适用场景|
  |-|-|-|-|
  |1.`body`**fixed**|简单兼容性好|页面回顶部|简单全屏弹窗|
  |2.阻止`touch`|体验好，兼容性好|实现稍复杂|适用推荐，需内部滚动的浮层|
  |3.`overscroll-behavior`|**极其简单，原生支持**|`IOS`老版本兼容性问题|现代浏览器首选，可作渐进增强|
  |4.`overflow:hidden`|不改定位|`IOS`可能无效，需`Hack`|可作为备选方案|  


##### 蒙层穿透 
> **蒙层穿透：在蒙层上滑动，阻止默认行为。**  

```html
<div id="modal-overlay" class="modal-overlay"> <!-- 这个是蒙层 -->
  <div class="modal-content">
    <div class="modal-header">我是标题</div>
    <div class="modal-body" id="modal-scroll-container"> <!-- 这个是内部可滚动区域 -->
      <!-- 很长很长的内容 -->
    </div>
  </div>
</div>
```  
```javascript
const overlay = document.getElementById("modal-overlay");  
const scrollContainer = document.getElementById("modal-scroll-container");  
// 1.解决蒙层穿透，阻止所有在蒙层上的滑动默认行为  
overlay.addEventListener("touchmove", (e)=>{  
  // 注意：如果事件发生在内部滚动元素上，它会冒泡到蒙层。  
  // 所以我们不能简单的全部阻止，需要判断事件源。  
  // 如果事件目标就是蒙层本身，才阻止。
  if(e.target === overlay){
    e.preventDefault();
  }
},{passive:false});
```
##### 结合方案
一个健壮的弹窗组件应该同时处理两种穿透情况：
1.蒙层穿透：在蒙层上滑动，阻止默认行为。
2.内部滚动边界穿透：在内部滚动元素滚动到顶部或底部时继续滑动，阻止默认行为。  

```html  
<div id="modal-overlay" class="modal-overlay"> <!-- 这个是蒙层 -->
  <div class="modal-content">
    <div class="modal-header">我是标题</div>
    <div class="modal-body" id="modal-scroll-container"> <!-- 这个是内部可滚动区域 -->
      <!-- 很长很长的内容 -->
    </div>
  </div>
</div>
```  
```javascript  
const overlay = document.getElementById('modal-overlay');
const scrollContainer = document.getElementById('modal-scroll-container');

// 1. 解决蒙层穿透：阻止所有在蒙层上的滑动默认行为
overlay.addEventListener('touchmove', (e) => {
  // 注意：如果事件发生在内部滚动元素上，它会冒泡到蒙层。
  // 所以我们不能简单地全部阻止，需要判断事件源。
  // 如果事件目标就是蒙层本身，才阻止。
  if (e.target === overlay) {
    e.preventDefault();
  }
}, { passive: false });

// 2. 解决内部滚动容器的边界穿透（复用之前的逻辑）
let startY = 0;
let initialScrollTop = 0;

scrollContainer.addEventListener('touchstart', (e) => {
  startY = e.touches[0].clientY;
  initialScrollTop = scrollContainer.scrollTop;
}, { passive: true });

scrollContainer.addEventListener('touchmove', (e) => {
  const currentY = e.touches[0].clientY;
  const deltaY = currentY - startY;

  const isAtTop = initialScrollTop === 0;
  const isAtBottom = initialScrollTop + scrollContainer.clientHeight >= scrollContainer.scrollHeight;
  const isDraggingDown = deltaY > 0;
  const isDraggingUp = deltaY < 0;

  if ((isAtTop && isDraggingDown) || (isAtBottom && isDraggingUp)) {
    e.preventDefault();
  }
  // 其他情况不阻止，允许内部正常滚动
}, { passive: false });
```  


#### `CSS`安全区域（`Safe Area`）适配解决方案   

在现代浏览器设备上，由于刘海屏、水滴屏、圆角设计及底部导航条的存在，我们需要确保内容显示在安全区域内，避免被这些设备安全特性遮挡。   
##### 设计思路  
1.使用`env()`函数和`constant()`函数获取安全区域插入值。  
2.为顶部导航栏适配安全区域上方空间。  
3.为底部导航栏适配安全区域下方空间。   
4.确保主要内容在安全区域内显示。  
5.添加可视化指示器以展示安全区域边界。  
 
> 使用`env(safe-area-inset-top)`,`env(safe-area-inset-bottom)`,`env(safe-area-inset-left)`和`env(safe-area-inset-right)` 可以获取设备的安全区域插入值。  

+ 顶部安全区域  
使用`padding-top：env(safe-area-inset-top)`为顶部导航栏添加适当的上内边距，避免内容被设备刘海或状态栏遮挡。
+ 底部安全区域  
使用`padding-bottom：env(safe-area-inset-bottom)`为底部元素添加适当的内边距，避免内容被底部导航条或手势栏遮挡。   
+ 左右安全区域  
使用`padding-left:env(safe-area-inset-left)`和`padding-right:env(safe-area-inset-right)`处理左右两侧安全区域。   

#### 移动端软键盘遮挡输入框解决方案   
##### 解决方案1：使用`CSS`固定布局   
通过设置适当的视口`meta`标签和`CSS`布局，可以减少遮挡问题。  


