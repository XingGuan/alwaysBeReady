## 前端模块化   
### 前端模块化及其意义  
#### 一、模块化的意义  
**模块化**是将大型软件系统分解为独立、可复用、可维护的小模块的过程。  
**主要意义：**  
1.**代码组织与结构清晰**
  + 将功能拆分为独立模块，提高代码可读性。  
  + 避免单个文件过长，便于维护  
2.**代码复用** 
  + 同一模块可在多处导入使用  
  + 减少重复代码，提升开发效率。  
3.**依赖管理**  
  + 明确模块间的依赖关系  
  + 工具可自动处理依赖（如`Webpack`、`Vite`）  
4. **命名空间隔离**  
  + 避免全局变量污染  
  + 每个模块都有自己的作用域  
5.团队协作  
  + 不同开发者可以同时开发不同模块  
  + 减少代码冲突  
#### 二、`JavaScript`模块化发展历程  
1.无模块化时代（全局变量）  
```javascript
// 全局变量污染  
var globalVar = 'value';  
function globalFunc(){}
```  
2.`IIFE`(立即执行函数表达式)  
```javascript
// 创建私有作用域  
var module-(function(){
  var privateVar = 'secret';  
  return {
    publicMethod：function(){}
  };
})();
```  
闭包是一个经典的`JavaScript`模块模式实现。 
为什么可以创建私有作用域？  
这是因为**函数作用域的闭包特性**：  
```javascript
var module = (function(){
  var privateVar = 'secret'; // 私有变量  
  return {
    publicMethod:function(){
      return privateVar;  // 可以访问私有变量   
    }
  };
})();
// 外部无法直接访问  
console.log(module.privateVar); // undefined  
console.log(module.publicMethod()); // secret
```  
原理：  
+ 立即执行函数创建了**独立的作用域**  
+ 函数内部的变量只在函数作用域内可见。  
+ 但内部函数（如 `publicMethod`）通过**闭包**保持了对父作用域的引用。  
+ 外部只能访问返回对象中的属性和方法。  
`publicMethod`是私有函数吗？  
**不是私有函数**，它是**公开方法**，但可以访问私有变量：  
```javascript
var module =(function(){
  var privateVar = 'secret';  
  // 真正的私有函数（外部无法访问）  
  function trulyPrivate(){
    console.log('This is truly private');
  }
  return {
    publicMethod:function(){
      trulyPrivate(); //可以调用私有函数
      return privateVar;
    }
  }
})();
module.publicMethod(); // 可以调用  
module.trulyPrivate(); // 报错：undefined is not a function
```    
+ 和全局函数的区别   
| 区别点     | 立即执行函数模块 | 全局函数         |
| ---------- | ---------------- | ---------------- |
| 作用域污染 | 无（局部作用域） | 有（全局作用域） |
| 私有变量   | 支持（通过闭包） | 不支持           |
| 封装性     | 高，实现信息隐藏 | 低，所有内容公开 |
| 命名冲突   | 不易发生         | 容易发生         |
| 内存占用   | 闭包可能占用更多 | 相对较少         |

#### 总结  
立即执行函数表达式通过 **函数作用域 + 闭包**实现了：  
1.**私有变量保护**：外部无法直接访问  
2.**公共接口暴露**：通过返回对象公开部分功能
3.**避免全局污染**：所有变量都在函数作用域内  
4.**数据封装**：实现面向对象的信息隐藏规则   

### 一、`CommonJS`（`Node.js`采用）  
```javascript
// 导出
module.exports = { functionA,functionB };  
exports.functionA = functionA;
// 导入
const { functionA } = require('./module');
```
```javascript
// 一.导出单个函数/类（类似默认导出）
module.exports = function(){}
// 导入方式 （1）.直接赋值给变量 
const myFunction = require('./module');
myFunction();
// 导入方式 （2）.直接调用   
require('./module')();

// 二.导出单个对象
module.exports = { functionA, functionB, property:'value'}
// 导入方法 （1）导入整个对象 
const myModule = require('./module');
// 导入方法 （2）解构赋值
const { functionA, functionB, property } = require("./module"); 

// 三.导出多个独立属性  
exports.functionA = functionA;
exports.functionB = functionB;
// 导入方式 （1）导入整个模块对象
const myModule = require('./module');
myModule.functionA();
myModule.functionB();  
// 导入方式 （2）解构导入  
const { functionA,functionB } = require("./module");  

// 四.导出构造函数  
function MyClass(){}   
module.exports = MyClass;
// 方式1：直接导入   
const MyClass = require('./MyClass.js');  
const instance = new MyClass();  
// 方式2：导入后重命名  
const MyConstructor = require("./MyClass.js");  
const instance = new MyConstructor();   
// 方式3：如果构造函数有默认导出，也可以这样（但一般不这么写）  
const { default:MyClass } = require("./MyClass.js");  
const instance = new MyClass();  

// 5.混合导出（先导出函数，再添加属性）  
module.exports = function(){};
module.exports.helper = function(){}  
// 导入 （1）整体导入(默认导入)  
const myModule = require('./module');  
// 使用默认函数  
myModule(); // 调用 module.exports = function(){} 的函数   
// 使用附加的 helper 方法   
myModule.helper();  // 调用 module.exports.helper 函数
// 导入 (2) 使用解构赋值  
const myModule = require('./module');
const { helper } = myModule;  
// 分别使用  
myModule(); // 调用主函数  
helper();  // 调用 helper 函数

// 6.动态导出   
if(condition){
  module.exports = functionA;
}else{
  module.exports = functionB;
}
```    
### 二、`AMD`（异步模块定义）  
```javascript
// RequireJS 这是RequireJS的模块定义语法，用于定义 JavaScript 模块并声明其依赖关系。  
define(['dep1','dep2']), // 依赖模块数组
  function(dep1,dep2){ // 工厂函数（依赖注入）
    return { // 模块的返回值
      method:function(){}
    }
});
```
#### 各部分解析  
1.`defined()`函数   
+ `RequireJS`的核心函数，用于定义模块。  
+ 符合`AMD` `（Asynchronous Module Definition）` 规范。   
2.依赖数组['dep1','dep2']  
+ 声明本模块依赖的其他模块  
+ 模块标识符对应文件路径（可配置）  
+ 会异步加载这些依赖  
3.工厂函数`function(dep1,dep2){……}`  
+ 依赖加载完成后执行   
+ 参数与依赖数组一一对应  
+ `dep1`,`dep2`是依赖模块的导出值   
4.返回值（模块导出）  
+ 工厂函数返回的对象就是模块的公共API  
+ 其他模块可以通过依赖注入使用这些方法   

```javascript
// math.js - 定义数学工具模块
define(['utils'], function(utils) {
  return {
    add: function(a, b) {
      return utils.validate(a) + utils.validate(b);
    },
    multiply: function(a, b) {
      return a * b;
    }
  };
});
// 另一个模块中使用
define(['math'], function(math) {
  console.log(math.add(2, 3)); // 使用 math 模块
});
```  
#### 与`CommonJS`对比   
```javascript
// RequireJS(AMD)  
define(['dep1','dep2'],function(d1,d2){
  return {};
})  
// Node.js (CommonJS)  
var dep1 = require('dep1');
var dep2 = require('dep2');  
module.exports = {};
```  
#### 配置示例  
```javascript
// main.js - 配置 RequireJS  
require.config({
  baseUrl:'js/lib',
  paths:{
    'jquery':'jquery.min',
    'underscore':'underscore.min',
  }
});
// 使用配置的模块  
define(['jquery','underscore'],function($,_){
  // 使用$ 和 _
})
```
#### 关键点：这种模式实现了：  
1.**依赖声明前置**—— 清晰知道模块依赖  
2.**异步加载**—— 不阻塞页面渲染  
3.**模块化**——避免全局命名空间污染   
4.**依赖注入**——松耦合，便于测试  

#### 主要使用场景
> `AMD`(`Asynchronous Module Definition`) 在现代前端开发中的使用场景已经大大减少，但仍有一些特定场景会用到：   
1.老项目维护  
+ 遗留系统：2015年前构建的大型企业应用  
+ 银行/金融系统：稳定性要求高，升级成本大的系统  
+ 政府/机构网站：更新频率低的传统应用  
+ 示例：一些仍在使用`jQuery + RequireJS`的`CMS`后台  

2.特定库的兼容性  
```javascript
// 一些老库仍提供`AMD`版本  
defined(['jquery',function($){
  // 如：一些老版本的 BootStrap 插件  
  $.fn.oldPlugin = function(){};
}])
```  
3.无构建工具环境  
+ 快速原型：直接浏览器运行，无需打包  
+ 教学演示：便于理解模块化概念  
+ 代码片段：在线编辑器（如早期 `CodePen`配置）  

4.大型单页应用的特殊需求  
// 动态按需加载（虽然现在用 `import()` 更常见）
```javascript
  require(['moduleA'],function(moduleA){
    if(user.isAdmin){
      require(['adminModule'],function(admin){
        admin.init();
      })
    }
  })
```  
#### 与现代技术的对比   
`AMD vs ES6 Modules`  
| 特性     | `AMD(RequireJS)` | `ES6 Modules + Webpack` |
| -------- | ---------------- | ----------------------- |
| 加载方式 | 运行时异步加载   | 构建时静态分析          |
| 语法     | 回调函数         | `import/export`声明式   |
| 树摇优化 | 不支持           | 支持                    |
| 类型支持 | 困难             | `TypeScript`友好        |
| 性能     | 多次`HTTP`请求   | 打包合并，减少请求      |

#### 现代替代方案  
```javascript
// ES6 Modules (现代标准)  
import { dep1,dep2 } from './modules';  
export default { method:function(){}}  
// 动态导入（类似 AMD 的按需加载）  
const module = await import('./module.js');  
// System.import('module');
```  
#### 仍在使用的典型案例  
```javascript
// Dojo Toolkit  
// Dojo 1.x 广泛使用 AMD  
require(['dojo/dom','dojo/on'],function(dom,on){
  on(dom.byId('button','click',function(){
    // ……
  }))
})
// 2.某些 `jQuery` 插件生态   
// 老式 jQuery 插件定义  
if(typeof defined === 'function' && defined.amd){
  // AMD 兼容  
  defined(['jquery'],function($){
    return plugin;
  })
}else{
  // 全局变量  
  window.jQueryPlugin = plugin;
} 
// 3.企业内部工具  
+ 构建脚本复杂：迁移成本过高  
+ 依赖老库：特定业务仅支持 `AMD`  
+ 团队技能：团队熟悉现有架构  
```  
#### 技术栈演变时间线  

2009: CommonJS (Node.js)
     ↓
2011: AMD/RequireJS (浏览器主导时期)
     ↓
2015: ES6 Modules 标准发布
     ↓
2016: Webpack 2+ 普及
     ↓
2018: 主流框架转 ES6 Modules
     ↓
2020+: Vite/Snowpack 基于 ES Modules    

#### 迁移策略  
如果你需要维护`AMD`项目：   
1.渐进式迁移   
```javascript
// 使用 webpack 的 AMD 兼容  
module.exports = {
  module:{
    rules:[
      //  同时支持 AMD 和 ES6  
    ]
  }
}  
// 或使用 `SystemJS` 作为过渡
```  
2.封装`AMD`模块  
```javascript
// 将 AMD 模块包装为 `ES6` 模块  
import $ from 'jquery';  
// 动态加载 AMD 模块  
const loadLegacyModule = (moduleName)=>{
  return new Promise((resolve)=>{
    require([moduleName],resolve);
  });
};
```  
3.工具辅助  
+ `requirejs-optimizer`:`AMD`打包优化  
+ `amd-to-es6`:代码转换工具  
+ `TypeScript AMD`配置   
#### 总结建议  
适合使用 `AMD`的场景：  
1. 维护现有 `AMD`项目  
2. 无构建步骤的简单页面  
3. 需要动态决定加载模块的特定需求  
4. 教学/演示模块化概念  
  
>  一句话总结：AMD 现在是前端考古学的一部分，主要用于维护老项目，新项目应该使用 ES6 Modules 等现代标准。它的历史贡献在于推动了浏览器端模块化的发展，为后续标准奠定了基础。    

> `Require.js`是一个**客户端模块加载器**，它遵循`AMD`规范，专门设计用于在浏览器中异步加载`JavaScript`模块。

```javascript
// 1.引入 Require.js
<script src="require.js"></script>
// 2.指定主模块入口  
<script>
  requirejs(['moduleA','moduleB'],function(moduleA,moduleB){
    // 模块加载完成后执行
  })
</script>
```
+ 



+ `CommonJS`  //用户服务端
+ `CMD`   
+ `AMD`  //浏览器端
+ `ES6`  //服务端和浏览器端通用  


### `CommonJS`  
`CommonJS`是以在浏览器环境之外构建`JavaScript`生态系统为目标而产生的项目，比如在服务器和桌面环境中。  
> `CommonJS`采用同步加载模块的方式，也就是说只有加载完成，才能执行后面的操作。   

>`CommonJS`代表：`Node`应用中的模块，通俗的说就是你用`npm`安装的模块。  

**`CommonJS` 加载模块，`require`导出模块`module.exports`** 



它使用`require`引用和加载模块，`exports`定义和导出模块，`module`标识模块。使用`require`需要去读取并执行该文件，然后返回`exports`导出的内容。  

```javascript
// 定义模块 math.js  
var random = Math.random()*10;
function printRandom(){
     console.log(random)
 }

 function printIntRandom(){
     console.log(Math.floor(random))
 }
 //模块输出
 module.exports={
     printRandom:printRandom,
     printIntRandom:printIntRandom
 }
 //加载模块 math.js
 var math=require('math');
 //调用模块提供的方法
 math.printIntRandom()
 math.printRandom()
```

## `ES6`模块化   
`ES6`模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。所以说`ES6`是**编译时加载**,不同于`CommonJS`的运行时加载(实际加载的是一整个对象)，`ES6`模块不是对象，而是通过`export`命令显示指定输出的代码，输入时也采用静态命令的形式。  

## 语法  
模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。

## 背景  


## 模块化的好处  
1.可维护性。  
 因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。   

2.命名空间。  
在`JavaScript`里面，如果一个变量在最顶级的函数之外声明，它就**直接变成全局可用**。因此，常常**不小心出现命名冲突的情况。**  
3.重用代码。
我们有时候喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。我们可以在更新了模块之后，让引用了该模块的所有项目都同步更新，还能指定版本号，避免`API`变更带来的麻烦。   
[前端模块化方案](https://zhuanlan.zhihu.com/p/134070306)  
[前端模块化](https://juejin.cn/post/7077560852877934622)   

## `ES6模块`   
[菜鸟教程ES6模块](https://www.runoob.com/w3cnote/es6-module.html)   
### `ES6模块特点`  
`ES6`的模块自动开启严格模式，不管你有没有在模块头部加上`use strict`;   
模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。   
每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。   
每一个模块只加载一次(是单例的)，若再去加载同目录下同文件，直接从内存中读取。   

### `export`与`import`  
### 基本用法   
模块导入导出各种类型的变量，如字符串，数值，函数，类。   
+ 导出的函数说明与类声明必须要有名称(`export default`命令另外考虑)。   
+ 不仅能导出声明还能导出引用(例如函数)。   
+ `export`命令可以出现在模块的任何位置，但必须处于模块顶层。   
+ `import`命令会提升到整个模块的头部，首先执行。   

建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。   
函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。   

### `as`的用法   
`export`命令导出的接口名称，须和模块内部的变量有一一对应关系。   
导入的变量名，须和导出的接口名称相同，即顺序可以不一致。   
```javascript
/*-----export [test.js]-----*/
let myName = "Tom";
export { myName as exportName }
 
/*-----import [xxx.js]-----*/
import { exportName } from "./test.js";
console.log(exportName);// Tom
使用 as 重新定义导出的接口名称，隐藏模块内部的变量
/*-----export [test1.js]-----*/
let myName = "Tom";
export { myName }
/*-----export [test2.js]-----*/
let myName = "Jerry";
export { myName }
/*-----import [xxx.js]-----*/
import { myName as name1 } from "./test1.js";
import { myName as name2 } from "./test2.js";
console.log(name1);// Tom
console.log(name2);// Jerry
```  
不同模块导出接口名称命名重复，使用`as`重新定义变量名。   
### `import`命令的特点   
**只读属性**：不允许在加载模块的脚本里面。改写接口的引用指向。即可以改写`import`变量类型为对象的属性值，不能改写`import`变量类型为基本类型的值。  
```javascript
import {a} from "./xxx.js";
a={};//error
import {a} from "./xxx.js";
a.foo ="hello";//a={foo:'hello'}
```  
**单例模式：**：多次重复执行同一句`import`语句，那么只会执行一次，而不会执行多次。`import`同一模块，声明不同接口引用，会声明对应变量，但只执行一次`import`。   
```javascript
import {a} "./xxx.js";
import {a} "./xxx.js";
// 相当于 import { a } "./xxx.js";  
import { a } from "./xxx.js";
import { b } from "./xxx.js";
// 相当于 import { a, b } from "./xxx.js";
```   
静态执行特性：`import`是静态执行，所以不能使用表达式和变量。  
```javascript
import { "f" + "oo" } from "methods";
// error
let module = "methods";
import { foo } from module;
// error
if (true) {
  import { foo } from "method1";
} else {
  import { foo } from "method2";
}
// error
```   
### `export default`命令   
+ 在一个文件或者模块中，`export`、`import`可以有多个，`export default`仅有一个。   
+ `export default`中的`default`是对应的导出接口变量。  
+ 通过`export`方式导出，在导入时要加`{}`,`export default`则不需要。   
+ `export default`向外暴露的成员，可以使用任意变量来接收。   

```javascript
var a = "My name is Tom!";
export default a; // 仅有一个
export default var c = "error"; 
// error，default 已经是对应的导出变量，不能跟着变量声明语句
 
import b from "./xxx.js"; // 不需要加{}， 使用任意变量接收
```
### 复合使用   
`export` 与 `import`可以在同一模块使用，使用特点：
+ 可以将导出接口改名，包括`default`。   
+ 复合使用`export`与`import`，也可以导出全部，当前模块导出的接口会覆盖继承导出的。   
```javascript
export {foo,bar} from "methods";   
export { foo, bar } from "methods";
 
// 约等于下面两段语句，不过上面导入导出方式该模块没有导入 foo 与 bar
import { foo, bar } from "methods";
export { foo, bar };
 
/* ------- 特点 1 --------*/
// 普通改名
export { foo as bar } from "methods";
// 将 foo 转导成 default
export { foo as default } from "methods";
// 将 default 转导成 foo
export { default as foo } from "methods";
 
/* ------- 特点 2 --------*/
export * from "methods";
```  




