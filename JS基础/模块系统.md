### 模块系统  
> 在`JavaScript`中，**ES模块(ESM)**和**CommonJS(CJS)**是两种不同的模块系统，它们在语法、加载机制和运行时有本质区别。以下是核心差异对比：   

1.语法不同  
+ `ESM`(现代标准)： 
```javascript
//导出  
export const value = 42;   
export default function(){};   
//导入   
import { value } from './module.js';
import func from './module.js';
```  
+ `CJS`(`Node.js`传统方式)  
```javascript
// 导出 
module.exports = { value:42 };
exports.value = 42;// 等效写法
// 导入  
const module = require('./module.js');
```  
2.加载机制  
|特性|ESM|CommonJS| 
|------|------|------|
|**加载时机**|静态解析（代码执行前解析依赖）|动态加载（运行时解析依赖）|
|同步/异步|支持异步加载（浏览器原生支持）|同步加载（阻塞执行）|
|await|支持|不支持|  

3.模块作用域  
+ **ESM**
  + 严格模式（"use strict"）强制启用   
  + 顶级`this`指向`undefined`  
  + 变量是**实时绑定**（导出值变化会影响导入值）。   
  
  ```javascript
  // counter.js (ESM)
  export let count = 1;
  setTimeout(() => { count = 2 }, 100);

  // main.js
  import { count } from './counter.js';
  console.log(count); // 初始值 1
  setTimeout(() => console.log(count), 200); // 2（值更新）
  ```   
  + **CommonJS**   
  + 非严格模式（除非手动启用）  
  + 变量是 **值拷贝**（导出后与原模块解耦）  
  
  ```javascript
    // counter.js (CJS)
    let count = 1;
    setTimeout(() => { count = 2 }, 100);
    module.exports = { count };

    // main.js
    const { count } = require('./counter.js');
    console.log(count); // 1
    setTimeout(() => console.log(count), 200); // 1（值不变）
  ```
4.循环依赖处理  
+ `ESM`：   
通过实时绑定解决循环引用，模块未初始化时访问会报错（TDZ暂存死区）。   
+ `CommonJS`:  
允许循环引用，但可能返回未初始化的模块副本（部分值为`undefined`）  

5.`Node.js`中的使用   
|文件类型|默认解析方式|强制指定方式|  
|---|---|---|
|`.js`|由`package.json`中的`type`决定|`"type":"module"`->ESM <br> `"type":"commonjs"`->CJS|
|`.mjs`|强制`EMS`|无需配置|
|`.cjs`|强制`CJS`|无需配置|

// package.json
```javascript
  "type":"module", // 所有.js 文件视为ESM
  "type":"commonjs" // 所有.js 文件视为CJS（默认）
```  
6.互操作性  
+ ESM——>CommonJS:  
可用`import`导入`CJS`模块（值作为`default`导出）：  
```javascript
 import cjsModule from './cjs-module.cjs';//通过 default 访问
```
+ CommonJS——>ESM:
必须用动态`import()`(异步)：  
```javascript
const esmModule = await import("./esm-module.mjs")
```
### 总结   
|**维度**|ESM|CommonJS| 
|**标准**|`ECMAScript` 官方标准|`Node.js`传统规范|
|**加载方式**|静态，异步|动态，同步|  
|**值传递**|实时绑定（引用）|值拷贝|
|**严格模式**|强制启用|需手动启用|
|**适用环境**|浏览器+Node.js（现代）|Node.js（旧项目）|  
|**文件扩展名**|`mjs`/`js`（需配置）|`cjs`/`js`（默认）|  


### 拓展   
1.基本区别  
|形式|含义|对应导出方式|
|`import {A} from 'x`|导入**命名导出**|`export cont A=……`|
|`import B from 'x'`|导入**默认导出**|`export default……`|
|`import * as C from 'x'`|导入**所有导出**（命名空间对象）|混合导出|  

2.何时使用花括号？   
使用花括号`{ }`的场景（命名导出）  
```javascript
//module.js   
export const apiKey = '123abc'; // 命名导出   
export function fetchData(){……} // 命名导出   
import {apiKey, fetchData} from './module.js';
```  
**特点：**  
+ 用于导入**多个独立的值/函数**。   
+ 名称必须与导出时**完全匹配**（大小写敏感）。  
+ 可重命名：`import { apiKey as key } from ……`   
+ 适合工具函数集、配置对象等   

3.何时不使用花括号？   
不使用花括号的场景(默认导出)
```javascript
export default class User {……}; // 默认导出   
import User from './UserComponent.js'; //无花括号 
```  
特点：   
+ 用于导入**模块的主要功能/主入口**。  
+ 导入时可**任意命名**(不需要匹配原名称)
+ 一个模块**只能有一个**默认导出   
+ 适合组件、主类、单例对象等  

4.混合导入   
可同时导入默认导出和命名导出：   
```javascript
export default function main(){……};
export const version = '1.0';
import mainUtil, {version} from './utils.js';
```  
总结表对比   
|特性|带花括号`{ }`(命名导出)|不带花括号(默认导出)|
|**导出数量**|多个|仅1个|
|**名称匹配**|必须精确匹配|可任意命名|
|**适用场景**|辅助函数/常量/工具方法|主类/组件/主要功能|
|**重构友好度**|高(直接重命名导出)|中（需修改所有导入点名称）|
|`Tree Shaking`|优化友好|需注意默认导出的副作用|
|使用频率|70%~80%|20%~30%|  

黄金法则：   
> 当模块提供多个**独立功能**时用命名导出（花括号导入），当模块代表**单一主体**时用默认导出（无花括号导入）。  


