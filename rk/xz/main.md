`DMA` 全称为**直接内存访问**，是一种计算机系统技术，它允许计算机中的某些硬件子系统（如硬盘驱动器、显卡、声卡、网卡等）直接与主内存进行数据读写，而无需**中央处理器的持续参与**。
计算机组成与体系结构>输入/输出技术

2.备忘录模式主要用于保存一个对象的某个状态，以便在适当的时候恢复对象。
3.策略模式定义了一系列的算法，并将每个算法封装起来，使它们可以相互替换。  
4.状态模式允许一个对象在其内部状态改变时改变它的行为。
5.开源软件是指其源代码可以被公众使用、修改和分发的软件。虽然开源软件的著作权归开发者所有，但是遵循开源许可协议，使用者可以自由使用、修改和分发该软件。
6.数据流图分层结构，各层数据流图之间应该保持"平衡"关系，即子图的输入输出流必须和父图中相应处理的输入输出数据流一致，该说法正确。 
顶层数据流图只包含一个处理框，表示待开发的系统，它抽象的描述了系统的功能
数据流图的层次越多，细节程度越高，随着分层细化，会逐步展现更多的处理过程和数据流动细节。
分层的数据流图可以清晰的表达系统的层次结构，使得系统便于理解。
7.在关系数据库中，第三范式的主要目的是消除**传递依赖**类型的问题，
在关系数据库中，第一范式（`1NF`）要求数据库表的每一列都是不可分割的基本数据项；
第二范式（`2NF`）在满足1NF的基础上，消除了非主键对主键的部分依赖；
第三范式（`3NF`）是在满足2NF的基础上，消除非主键对主键的传递依赖。
多值依赖是第四范式（`4NF`）要处理的问题；
8.顺序内聚：一个模块中各个处理元素和同一个功能密切相关，而这些处理必须顺序执行。通常前一个处理元素的输出是后一个处理元素的输入。  
功能内聚：模块内所有元素的各个组成部分全部为完成同一个功能而存在，共同完成一个单一的功能，模块已不可在再分。  
通信内聚：指模块内所有处理元素都在同一个数据结构上操作或所有处理功能都能通过公用数据而发生关联。  
巧合内聚：一个模块内的各处理元素之间没有任何联系，只是偶然地被凑在一起。
9.微服务架构：将系统拆分为独立部署的服务（订单处理、支付网关），通过`API`通信，符合高内聚低耦合原则。  
分层架构：按功能层划分（如展示层，业务层），不强调服务独立性。
面向对象：以类和对象为核心，与分布式服务无关。  
事件驱动：通过事件队列通信。
10.中断分类：
软件中断：由程序错误（如除零、非法指令）触发，CPU主动抛出异常。
硬件中断：按键输入、定时器溢出属于外部设备触发。
电源故障：系统级硬件故障，非程序逻辑引起。  
11.正数的 反码 ，补码 和其原码是一样的
负数的 反码 是其在原码基础上保持其第一位符号位不动，其它位按位取反
负数的 补码是其在反码基础上加1，超过8位，可舍弃最高位 
补码，负数通过反码转补码，符号位参与加1计算
原码、反码、补码都拥有一个符号位。
0 是表示正数
1 是表示负数
现代计算机中，有符号整数一律用补码来表示和存储。  
12.移码  
定义：在补码的基础上，将符号位取反。  
移码 = 补码 + 2^(n-1) (对于位数，相当于将整个数字向右平移了2^(n-1))
目的：移码主要用于比较浮点数指数部分的大小
> 在浮点数的表示（如 IEEE 754 标准）中，指数部分使用移码。  
优势：移码使得所有数字的表示本身（看作无符号数）的大小顺序，与其代表的实际数值的大小顺序是完全一致的。
> 计算机内部用补码存有符号整数。
> 移码是补码的符号位取反，专门给浮点数的指数部分用。
> 原码和反码是理解补码演变过程的重要概念，但实际已不在运算中使用。
13.在浮点数中，一个数字被表示为：  
数值=尾数*基数^指数  
在科学计数法中：6.02 * 10^23 
+ 尾数：6.022
+ 基数：10
+ 指数：23  
当计算机对两个浮点数进行加减运算时，第一步必须是**对齐指数**（也叫"对阶"）。
这就像你要把 5.2 * 10² 和 3.1* 10³相加，必须先统一指数：  
`5.2*10²+0.31*10³=5.51*10³`  
为了决定哪个数需要调整尾数，计算机需要快速比较两个指数的大小。  
> 问题所在：用补码比较指数很麻烦
> 这意味着如果直接用补码的二进制模式进行比较，计算机会错误地认为 -2 (254) 比 +2 (2) 大！硬件需要额外的逻辑来判断符号位，这降低了比较速度。 

> 移码的巧妙解决方案  
> 移码通过一个简单的变换解决了这个问题：移码=实际指数+偏移量  
对于8位指数，通常偏移量是127（即 2^7 - 1）。这样：  
+ 实际指数范围： -127 到 +128 
+ 移码范围：0 到 255 

> IEEE 754标准
> 在广泛使用的IEEE 754浮点数标准中：
> 单精度（32位）：指数用8位移码，偏移量 = 127
> 双精度（64位）：指数用11位移码，偏移量 = 1023

> 总结
> **"移码主要用于比较浮点数指数部分的大小" 这句话的意思是：
移码通过给指数加上一个固定的偏移量，使得：
所有指数都变为非负数
指数的大小顺序与它们的二进制表示的顺序完全一致
硬件可以用最简单、最快的方式（无符号整数比较）来判断哪个指数更大
这样一来，浮点数的对阶操作（对齐指数）就可以高效地进行，这是浮点数加减法能够正确执行的关键第一步。**  

14.浮点数运算**移码偏移量**的选择  
对于 **n位** 的指数，偏移量通常选择为 2^(n-1)-1。  
eg：对于8位指数（n=8）：  
+ 偏移量 = 2^(8-1)-1=2^7-1 = 128 - 1 = 127  
这个偏移量的选择是为了让指数范围关于0对称。  
2.移码范围的计算   
移码 = 实际指数 + 偏移量  
最小移码：  
+ 当实际指数最小时，移码最小
+ 最小移码 = 最小实际指数 + 127 
最大移码：
+ 当实际指数最大时，移码最大
+ 最大移码 = 最大实际指数 + 127
由于移码用8位无符号整数表示，其理论范围是0到255  
3.实际指数范围的计算  
现在我们反推实际指数的范围：
从最小移码求最小实际指数：
+ 最小移码 = 0
+ 0 = 最小实际指数 + 127
+ 最小实际指数 = 0 - 127 = -127
从最大移码求最大实际指数：
+ 最大移码 = 255
+ 255 = 最大实际指数 + 127
+ 最大实际指数 = 255 - 127 = 128
4.验证对称性 
让我们检查这个范围是否对称：
+ 最小实际指数：-127
+ 最大实际指数：+128
+ 范围跨度：128 - (-127) = 255
看起来不是完全对称（-127到+128），这是为什么呢？
**原因**：8位无符号数的范围是0-255，共256个值。为了充分利用所有编码，设计上允许正数范围比负数范围多1个值。

15.指令寄存器IR：用于存储当前正在执行的指令。当`CPU`从内存中取指令时，指令被加载到指令寄存器（IR）中，然后`CPU`根据`IR`中的内容执行操作。`IR`直接保存即将被执行的指令代码。
16.程序计算器PC：存储下一条要执行的指令的地址，而不是指令本身。  
17.指令译码器ID：负责解码`IR`中的指令，生成控制信号，但不存储指令。  
18.地址寄存器：用于存储内存地址，用于寻址操作，不存储指令。  

