<!--
 * @Descripttion: 
 * @Author: GXing
 * @Date: 2025-11-06 23:09:33
-->
1.什么是前趋图？
> 前趋图，也叫前驱图，是一种**有向无环图**，用于描述多个任务或进程之间的**先后执行关系**。    

1.1关键点解析：  
（1）“圈”：由**节点**和**有向边**组成。  
+ **节点**：代表一个任务、一个程序或一个进程。  
+ **有向边**：用箭头"→"表示，箭头从节点A指向节点B，意味着"**A必须在B开始之前完成**"。我们称A是B的**前趋**，B是A的**后继**。     
  
（2）"前趋"：强调的就是这种"谁必须在谁之前"的先后顺序和依赖关系。  
（3）"无环"：图中**不能存在循环**。也就是说，你不能找到一个路径，从某个节点出发，沿着箭头方向走，最后又回到这个节点。如果存在环，就意味着任务之间产生了死锁（例如，A等B 完成 ，B 等 C 完成， C 又等A完成 ），这在逻辑上是无法执行的。  
1.2 前趋图在计算机科学中的主要应用
前趋图最主要的领域是**操作系统**，尤其是在**进程管理**中。  
（1）描述程序的顺序执行
+ 一个复杂的程序可以分成多个程序段。
+ 前趋图可以明确规定这些程序段必须以何种顺序执行。     
  
（2）分析进程的并发执行   
+ 操作系统可以利用前趋图来调度进程。那些没有先后依赖关系的进程（如图中的煮鸡蛋、烤面包、热牛奶）可以并发执行，从而提高系统效率。
+ 它可以用来判断一个并发程序是否存在“ Bernstein 条件”，以确定两个进程是否可以并行运行而不会产生数据竞争。   

（3）确保进程同步 
+ 操作系统可以利用前趋图来调度进程。那些没有先后依赖关系的进程（如图中的煮鸡蛋、烤面包、热牛奶）可以并发执行，从而提高系统效率。

> 总结：简单来说，前趋图就是一个描述“做事顺序”的流程图，它核心回答了这个问题：在做这件事之前，必须先把哪些事做完？  
> 它的主要特点是：  
直观：清晰地展示了任务间的依赖关系。  
强调顺序：定义了严格的执行先后次序。  
支持并发：帮助识别哪些任务可以同时进行。  
无环：保证了逻辑的合理性和可行性。   
它是理解复杂任务调度、进程并发和同步的一个非常基础和重要的工具。

2.什么是`PV`操作？
> `PV` 操作是处理多线程/多进程环境下，临界资源（一次只能被一个进程使用的资源，比如打印机、共享变量等）访问问题的核心工具。它就像是一个交通信号灯或者一把钥匙，确保在任何时候，只有一个“人”能进入关键区域（临界区）工作。  

详细解释
（1）核心概念：信号量
要理解 `PV` 操作，必须先了解信号量。

信号量：可以理解为一个整数计数器，它记录着当前可用的“资源数量”。这个计数器配合一个等待队列使用。

当计数器值 > 0：表示有空闲资源，进程可以申请使用。

当计数器值 = 0：表示资源已被用完，下一个想申请资源的进程必须等待。

计数器值不能为负。如果为负，其绝对值表示正在等待该资源的进程数量。  

(2) `P` 操作和 `V` 操作的定义  
`PV` 操作是定义在信号量上的两个原子操作（即不可被中断的操作，要么全做，要么不做）。  
> P 操作（来自荷兰语 Proberen，意为“尝试”或“申请”）
+ 作用：申请一个资源，信号量值减 1。
+ 具体流程：  
    1.将信号量的值减1。  
    2.如果信号量的新值 >= 0,说明申请成功，该进程可以继续执行，进入临界区。
    3.如果信号量的新值 < 0（即减1后变成了负数），说明资源已被占用完毕，该进程被阻塞，并放入该信号量的等待队列中。

>`V` 操作（来自荷兰语 Verhogen，意为“增加”或“释放”） 
+ 作用：释放一个资源，信号量值加 1。
+ 具体流程：
    1.将信号量的值加 1。
    2.如果信号量的新值 > 0，说明没有进程在等待，直接返回。
    3.如果信号量的新值 <= 0（即加1后还是负数或零），说明等待队列中有正在阻塞的进程，此时需要唤醒等待队列中的第一个进程。

> PV 操作的两种主要用途  

(1) 实现互斥  
    目标：保证多个进程不同时进入临界区。  
    信号量初始值：1（像一把钥匙，只有一把）。  
(2) 流程：  
    进入临界区前执行 P(S) （拿钥匙，如果没钥匙就等）  
    在临界区中操作共享资源  
    离开临界区后执行 V(S) （还钥匙）  
```
semaphore mutex = 1; // 互斥信号量

Process() {
    P(mutex);    // 申请进入临界区
    // ... 临界区代码 (操作共享资源) ...
    V(mutex);    // 离开临界区，释放
}
```  
(2) 实现同步（协调进程的执行顺序）   
目标：让进程A必须等待进程B完成某项工作后才能继续。  
信号量初始值：0（表示“期待的事件”尚未发生）。  
流程：  
进程A在需要等待的地方执行 P(S) （如果事件没发生，就阻塞等待）  
进程B在完成工作后执行 V(S) （发出信号，通知事件已发生，唤醒A）  
```
semaphore done = 0; // 同步信号量

Process_A() {
    // ... 做一些准备工作 ...
    P(done);    // 等待B发出的完成信号
    // ... 继续后续工作 ...
}

Process_B() {
    // ... 执行关键工作 ...
    V(done);    // 关键工作完成，通知A可以继续了
}
```  
> 总结：P 操作：是 “申请” 和 “等待”。就像伸手去拿钥匙，拿不到就原地等待。  
V 操作：是 “释放” 和 “通知”。就像归还钥匙，并告诉等待的人：“钥匙还回来了，你们谁用？”  

>核心价值：通过这两个简单的、不可中断的原子操作，完美地解决了并发程序中的互斥（不打架）和同步（配合有序）两大核心难题。它是操作系统、数据库、并发编程等领域最基础、最重要的概念之一。

3.文件在磁盘上非连续存放，逻辑上相邻数据块的平均移动距离为5个磁道。读取每个数据块时，需要计算寻道时间、旋转延迟时间和传输时间。    

寻道时间：逻辑上相邻数据块之间的平均移动距离为5个磁道，移动一个磁道需要2ms，因此每次块间移动的寻道时间为5 × 2ms = 10ms。 100块  100*10ms = 1000ms。

旋转延迟时间：每块的旋转延迟时间为10ms，100块的总旋转延迟时间为100 × 10ms = 1000ms。  

传输时间：每块的传输时间为1ms，100块的总传输时间为100 × 1ms = 100ms。

4.`m`阶`B-`树  
这是一个非常重要且常用的数据结构，特别是在数据库和文件系统领域。
（1） **m阶B-树**是一种平衡的多路搜素树，它满足以下性质：  
    + 每个节点最多有`m`个子节点：`m`就被称为`B-`树的阶。
    + **每个非根节点至少有**`ceil(m/2)个`子节点**（根节点除外）
      + `ceil()`是向上取整函数。
      + 这个"至少"的规定保证了节点的利用率，避免树过于"稀疏"。
      + 非跟非叶子节点的最小子节点树也称为`B-`树的最小度数t（t = ceil(m/2)）。在许多教材中，使用`t`来定义`B-`树。   
      + 跟节点至少有两个叶子节点（除非它同时也是叶子节点）。
      + **所有叶子节点都位于同一层**。这是一个关键特性，它保证了树的绝对平衡。
      + **一个非叶子节点如果有`k`个子节点，则它包含（k-1）个键**。这些键按升序排列，充当子树之间的分隔值。
  
5.无向图`G`采用邻接矩阵存储时。矩阵的大小由顶点数`n`决定，与边数`e`无关。邻接矩阵式一个 n行n列的方阵，因此矩阵的大小为 n * n 。    

6.若无向图G有n个顶点e条边，则G采用邻接表存储时，邻接表的大小为？
当无向图G采用邻接表存储时，邻接表的“大小”通常指的是所有表结点（边结点）与所有表头结点（顶点结点）所占用的总存储空间。

我们可以将其分为两部分计算：

表头结点数组（顶点数组）：
这个数组的大小与顶点数 n 直接相关。无论图中有多少条边，这个数组都固定有 n 个表头结点。

大小 = n

边结点链表：
在无向图中，每条边 (u, v) 会在两个顶点对应的链表中出现。一次在顶点 u 的链表中（表示为 v），另一次在顶点 v 的链表中（表示为 u）。
因此，对于 e 条边，总共需要创建 2e 个边结点。

大小 = 2e

结论：

将两部分相加，采用邻接表存储时，整个邻接表的总大小（即表头结点和边结点的总数）为 n + 2e。

7.把一棵二叉树想象成由 根节点 (N)、左子树 (L) 和 右子树 (R) 三部分组成。遍历的本质就是决定访问这三者的顺序。  
三种基本深度优先遍历  
这三种方式是基础，它们的名字来源于根节点被访问的时机。  
前序遍历

顺序：根 -> 左 -> 右 (NLR)

过程：先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树。

特点：第一个访问的元素一定是整棵树的根。

应用：用于复制一棵树的结构。如果你想在文件系统中列出一个目录树的结构（显示深度），前序遍历非常直观。


中序遍历

顺序：左 -> 根 -> 右 (LNR)

过程：先递归地中序遍历左子树，然后访问根节点，最后递归地中序遍历右子树。

特点：对于二叉搜索树，中序遍历会得到一个升序的有序序列。这是它最重要的特性。

应用：主要用于BST，以有序的方式输出所有节点。

后序遍历

顺序：左 -> 右 -> 根 (LRN)

过程：先递归地后序遍历左子树，然后递归地后序遍历右子树，最后访问根节点。

特点：根节点总是在最后被访问。

应用：用于删除一棵树（必须先删除子节点再删除父节点）。也常用于计算一个目录及其子目录的总大小（必须先知道子目录的大小，才能计算父目录的总大小）。  

一种广度优先遍历
层次遍历

顺序：从上到下，从左到右，逐层访问。

过程：使用队列辅助实现。首先将根节点入队，然后只要队列不为空，就出队一个节点并访问它，接着将这个节点的左孩子和右孩子（如果存在）依次入队。

特点：按树的“层级”输出结果。

应用：需要按层级处理数据时使用，例如寻找最短路径（在树中）、打印树的结构等。

8.对于拓扑序列，需要按照有向图的指向，明确其先后顺序。
拓扑排序是针对有向无环图 的顶点进行排序的算法。
核心思想
拓扑排序的目的是将一个有向图的所有顶点排成一个线性序列，使得对于图中任何一条有向边 <u, v>（从 u 指向 v），在序列中 顶点 u 都出现在顶点 v 的前面。  

9.二叉树的高度是指其层数，空二叉树的高度为0,仅有根结点的二叉树高度为1，若某二叉树中共有1024个结点，则该二又树的高度是整数区间？  

对于一棵二叉树，其高度取决于树的形状。当树为完全二叉树时，高度最小；当树为链状结构时，高度最大。  

给定二叉树有1024个结点：

最小高度：高度为h的完全二叉树最多有2^h - 1个结点。当h=10时，最多有2^10 - 1 = 1023个结点，不足1024。因此，最小高度为11。

最大高度：当树为链状结构时，高度等于结点数，即1024。

因此，该二叉树的高度整数区间为[11, 1024]。

9.一般来说，关键路径是项目中时间最长的路径，决定了项目的最短完成时间。关键路径上的活动一旦延期，就会直接影响项目进度，因为这些活动没有浮动时间（slack time）。  
10.采用面向对象方法进行系统开发时，需要对两者之间的关系创建新类的是：
这里可以参照E-R图中的联系转换，多对多联系需要单独转换为一个关系模式，也需要重新建类。

11.在领域类模型中会涉及描述自身情况的属性与操作，还会描述类之关联的关系，但不会有对象层次的内容。
12.面向对象技术中，组合关系表示，整体与其部分之间的一种关系。
12.UML类图中类与类之间的关系有五种：依赖、关联、聚合、组合与继承。
