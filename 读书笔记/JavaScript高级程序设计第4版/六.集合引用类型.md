# 集合引用类型   
+ 对象
+ 数组与定型数组
+ `Map`、`WeakMap`、`Set`以及`WeakSet`类型。  
##  Object   
到目前为止，大多数引用值的示例使用的是`Object`类型。  
`Object` 是`ECMAScript`中最常用的类型之一。  
虽然`Object`的实例没有多少功能,但很适合存储和在应用程序间交换数据。  
显式地创建`Object`的实例有两种方式。第一种是使用`new`操作符和`Object`构造函数：
```javascript
    let person = new Object(); 
    person.name = "Nicholas"; 
    person.age = 29; 
```  
第二种是使用**对象字面量**表示法：
```javascript
    let person = { 
        name: "Nicholas", 
        age: 29 
    }; 
```  
在这个例子中，左大括号`（{）`表示对象字面量开始，因为它出现在一个**表达式上下文**`（expression context）`中。
>在`ECMAScript`中，表达式上下文指得的是期待返回值值的上下文。在`ECMAScript`中，表达式上下文指的是期待返回值的上下文。  

赋值操作符表示后面要期待一个值，因此左大括号表示一个表达式的开始。同样是左大括号，如果出现在**语句上下文**`（statement 
context）`中，比如 `if `语句的条件后面，则表示一个语句块的开始。   
>逗号用于在对象字面量中分隔属性。  

>在对象字面量表示法中，属性名可以是字符串或数值。数值属性会自动转换为字符串。    

>注意 在使用对象字面量表示法定义对象时，并不会实际调用`Object`构造函数。  

属性一般是通过**点语法**来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：
```javascript
console.log(person["name"]); // "Nicholas" 
console.log(person.name); // "Nicholas" 
```  
>从功能上讲，这两种存取属性的方式没有区别。

>1.使用中括号的主要优势就是可以通过变量访问属性。
```javascript
let propertyName = "name";
console.info(person[propertyName]);
```
>2.如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，可以使用中括号语法。比如：
```javascript
person['first name'] = 'Nicholas';
``` 
因为`"first name"`中包含一个空格，所以不能使用点语法来访问。不过，属性名中是可以包含非字母数字字符的，这时候只要用中括号语法存取它们就行了。  
通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。  
## Array  
`ECMAScript`数组跟其他编程语言的数组有很大区别。跟其他语言中的数组一样，`ECMAScript`数组也是一组有序的数据，但跟其他编程语言不同的是，数组中每个槽位可以存储任意类型的数据。  
### 创建数组  
+ 使用`Array`构造函数。
```javaScript
let colors = new Array();
```  
> 注意：构造函数这里可以在知道数组中元素的数量时候，直接给构造函数传入一个数值。`let colors = new Array(20);`，这个`length`就会被自动创建并设置为这个值，这里就会创建一个初始`length`为20的数组。——也可以给`Array`构造函数传入要保存的元素，`let colors = new Array("red","blue","green");` ,这段代码会创建一个包含3个字符串值的数组。  

> 创建数组时可以给构造函数传一个值。这个时候就有点问题了，因为如果这个值是数值，则会创建一个长度为指定数值的数组。而如果这个值是其他类型的，则会创建一个只包含该特定值的数组。  
```javascript
let colors = new Array(3); // 创建一个包含 3 个元素的数组
let names = new Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组
```  
> 在使用`Array`构造函数时，也可以省略`new`操作符。结果是一样的。

+ 使用**数组字面量**表示法。数组字面量是在中括号中包含以逗号分隔的元素列表。  
```javascript
let colors = ["red", "blue", "green"]; // 创建一个包含 3 个元素的数组
let names = []; // 创建一个空数组
let values = [1,2,]; // 创建一个包含 2 个元素的数组  
```   
>注意:与对象一样，在使用数组字面量表示法创建数组不会调用`Array`构造函数。  

> `Array`构造函数还有两个`ES6`新增的用于创建数组的静态方法：`from()`和`of()`。  

> `Array.from()`的第一个参数是一个类数组的对象，即任何可迭代的结构，或者有一个`length`属性和可索引元素的结构。

`Array.from()`方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。  

`Array.of()`可以把一组参数转换为数组。这个方法用于替代在`ES6`之前常用的`Array.prototype.slice.call(arguments)`,一种异常笨拙的将`arguments`对象转换为数组的写法:
```javascript
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] 
console.log(Array.of(undefined)); // [undefined] 
```  
### 数组空位  
使用数组字面量初始化数组时，可以使用一串逗号来创建空位。`ECMAScript` 会将逗号之间相应索引位置的值当成空位，`ES6`规范重新定义了该如何处理这些空位。  ES6 新增的方法和迭代器与早期 ECMAScript 版本中存在的方法行为不同。ES6 新增方法普遍将这些空位当成存在的元素，只不过值为undefined：
```javascript
const options = [1,,,,5]; 
for (const option of options) { 
 console.log(option === undefined); 
} 
// false 
// true 
// true 
// true 
// false 
```  
ES6 之前的方法则会忽略这个空位，但具体的行为也会因方法而异：  
```javascript
const options = [1,,,,5]; 
// map()会跳过空位置
console.log(options.map(() => 6)); // [6, undefined, undefined, undefined, 6] 
// join()视空位置为空字符串
console.log(options.join('-')); // "1----5" 
```  
> 注意:由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 undefined 值代替。  

### 数组索引  
&emsp;&emsp;要取得或设置数组的值，需要使用中括号并提供相应值的数字索引。如果索引小于数组包含的元素数，则返回存储在相应位置的元素，如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加1。  
&emsp;&emsp;数组中元素的数量保存在`length`属性中，这个属性始终返回0或大于0的值(数组`length`属性的独特之处在于，它不是只读的。通过修改`length`)属性，可以从数组末尾删除或添加元素。
```javascript
let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 2; 
alert(colors[2]); // undefined 
```  
```javascript
let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 4; 
alert(colors[3]); // undefined
```  
使用`length`属性可以方便地向数组末尾添加元素。
```javascript
let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors[colors.length] = "black"; // 添加一种颜色（位置 3）
colors[colors.length] = "brown"; // 再添加一种颜色（位置 4）
```  
数组中最后一个元素的索引始终是`length - 1`,因此下一个新增槽位的索引就是`length`。每次在数组最后一个元素后面新增一项，数组的`length`属性都会自动更新，以反映变化。换句话说，就是`length`属性会更新为位置加1。  

> 注意 数组最多可以包含4294967295个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。  

### 检查数组
**一个经典的ECMAScript问题是判断一个对象是不是数组。**在只有一个网页(因而只有一个全局作用域)的情况下，使用`instanceof`操作符就足矣:  
```javascript
if(value instanceof Array){
    // 操作数组
}
```  
使用`insatnceof`的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此会有两个不同版本的`Array`构造函数。如果要**把一个数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组**。  
为解决这个问题,`ECMAScript`提供了`Array.isArray()`方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。
```javascript
if(Array.isArray(value)){
    // 操作数组
}
```  
### 迭代器方法  
在`ES6`中,`Array`的原型上暴露了3个用于检索数组内容的方法：`keys()`、`values()`、和`entries()`。`keys()`返回数组索引的迭代器，`values()`返回数组元素的迭代器，而`entries()`返回索引/值对的迭代器:
```javascript
    const a = ["foo", "bar", "baz", "qux"];     
```  
// 因为这些方法都返回迭代器，所以可以将它们的内容通过`Array.from()`直接转换为数组实例  
```javascript
const aKeys = Array.from(a.keys());
const aValues = Array.from(a.values()); 
const aEntries = Array.from(a.entries());  

console.log(aKeys); // [0, 1, 2, 3] 
console.log(aValues); // ["foo", "bar", "baz", "qux"] 
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]    
```    
使用`ES6`的解构可以非常容易地在循环中拆分键/值对：
```javascript
const a = ["foo", "bar", "baz", "qux"]; 
for (const [idx, element] of a.entries()) { 
 alert(idx); 
 alert(element); 
} 
// 0 
// foo 
// 1 
// bar 
// 2 
// baz 
// 3 
// qux 
```  
### 复制和填充方法  
&emsp;&emsp;`ES6`新增了两个方法，批量复制方法`copyWithin()`,以及填充数组方法`fill()`。这两个方法的函数签名类似，都需要指定既有数组数组实例上的一个范围，包含开始索引，不包含结束索引。**使用这个方法不会改变数组的大小。**  
&emsp;使用`fill()`方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引:   
```javascript
const zeroes = [0,0,0,0,0];  
/* 用5填充整个数组 */
zeroes.fill(5);
console.log(zeroes); //[5,5,5,5,5] 
zeroes.fill(0); //重置  

/* 用7填充索引大于1且小于3的元素 */
zeroes.fill(7, 1, 3); 
console.log(zeroes); // [0, 7, 7, 0, 0]; 
zeroes.fill(0); // 重置  

// 用 8 填充索引大于等于 1 且小于 4 的元素
// (-4 + zeroes.length = 1) 
// (-1 + zeroes.length = 4) 
zeroes.fill(8, -4, -1); 
console.log(zeroes); // [0, 8, 8, 8, 0];  
`fill()`静默忽略超出数组边界、零长度及方向相反的索引范围。  
const zeroes = [0, 0, 0, 0, 0]; 
// 索引过低，忽略
zeroes.fill(1, -10, -6); 
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引过高，忽略
zeroes.fill(1, 10, 15); 
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引反向，忽略
zeroes.fill(2, 4, 2); 
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引部分可用，填充可用部分
zeroes.fill(4, 3, 10) 
console.log(zeroes); // [0, 0, 0, 4, 4] 
```    
与`fill()`不同，`copyWithin()`会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与`fill()`使用同样的计算方法:  
```javascript
let ints, 
 reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset();
/* 从ints中复制索引0开始的内容，插入到索引5开始的位置 */  
/* 在源索引或目标索引到达数组边界时停止 */
ints.copyWithin(5);
console.log(ints);//[0,1,2,3,4,0,1,2,3,4];   
reset();  
/*  从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置 */
ints.copyWithin(0, 5); 
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]  
reset();   

// 从 ints 中复制索引 0 开始到索引 3 结束的内容
// 插入到索引 4 开始的位置
ints.copyWithin(4, 0, 3); 
alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] 
reset();   

// JavaScript 引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6); 
alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] 
reset(); 

// 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的
ints.copyWithin(-4, -7, -3); 
alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]   

`copyWithin()`静默忽略超出数组边界、零长度及方向相反的索引范围：
```       






>函数签名(或者类型签名方法签名)定义了函数或方法的输入与输出  
&emsp;签名可包含:   
&emsp;&emsp; 参数及参数的类型  
&emsp;&emsp; 返回值及其类型  
&emsp;&emsp; 可能抛出或传出的异常  
&emsp;&emsp; 该方法在面向对象程序中可用性方面的信息(如`public`、`static`或`prototype`)  

>`JavaScript`是一种松散型或动态语言。这意味着你不必提前声明变量的类型。类型将在程序处理时自动确定。   

类型将在程序处理时自动确定。`JavaScript`中的签名仍然可以提供有关该方法的一些信息:  
```javascript
MyObject.prototype.myFunction(value)
```  
+ 该方法是安装在一个名为`MyObject`的对象上面  
+ 该方法安装在`MyObject`的原型上(因此它是一个实例方法)，而不是`static`或`public`。  
+ 该方法名为`myFunction`
+ 该方法接收一个参数，该参数被称为`value`,并且`value`没有进一步定义。   





# 思考  

1.创建Object的实例的方法有哪些？  
2.如何判断一个对象是不是数组？  
3.什么是函数签名？`JavaScript`中的签名?  














