#  一、拆阅章节(第四章)

# 变量、作用域与内存    


- [一、拆阅章节(第四章)](#一拆阅章节第四章)
- [变量、作用域与内存](#变量作用域与内存)
- [总结](#总结)
- [原始值与引用值](#原始值与引用值)
  - [复制值](#复制值)
  - [传递参数](#传递参数)
  - [确定类型](#确定类型)
- [4 执行上下文与作用域](#4-执行上下文与作用域)
  - [作用域链增强](#作用域链增强)
  - [变量声明](#变量声明)
  - [使用`const`的常量声明](#使用const的常量声明)
  - [标识符查找](#标识符查找)
- [垃圾回收](#垃圾回收)
  - [标记清理](#标记清理)
  - [引用计数](#引用计数)
  - [内存管理](#内存管理)
  - [内存泄漏](#内存泄漏)
  - [静态分配与对象池](#静态分配与对象池)
- [思考](#思考)
# 总结
>`JavaScript`变量可以保存两种类型的值:原始值和引用值。原始值可能是以下6种原始数据类型之一:`Undefined`，`Null`,`Boolean`,`Number`,`String`和`Symbol`。
原始值和引用值有以下特点。   
+ 原始值大小固定,因此保存在栈内存上。
+ 从一个变量到另一个变量复制原始值会创建该值的第二个副本。   
+ 引用值是对象，存储在堆内存上。
+ 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。   
+ 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。
+ `typeof`操作符可以确定值的原始类型，而`instanceof`操作符用于确保值的引用类型。   

>任何变量(不管是原始值还是引用值)都存在于某个执行上下文中(也称为作用域)。这个上下文(作用域)决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。  
+ 执行上下文分为全局上下文、函数上下文和块级上下文。  
+ 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。
+ 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。   
+ 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。  
+ 变量的执行上下文用于确定什么时候释放内存。    
>`JavaScript`是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。`JavaScript`的垃圾回收程序可以总结如下:   
+ 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。  
+ 主流的垃圾回收算法是标记清理，即给当前不在使用的值加上标记，再回来回收他们的内存。  
+ 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。`JavaScript`引擎不再使用这种算法，但某些旧版本的`IE`仍然会受这种算法的影响，原因是`JavaScript`会访问非原生`JavaScript`对象(如DOM元素)。  
+ 引用计数在代码中存在循环引用时会出现问题。  
+ 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也会有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。   


# 原始值与引用值
**只有引用值可以动态添加后面可以使用的属性，原始值不能有属性。**  

## 复制值
除了存储方式不同,原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。新变量和原始值是完全独立的，因为它是那个值的副本。   

>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在位置。区别在于这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象,因此一个对象上的变化会在另一个对象上反映出来。  

## 传递参数  
>ECMAScript中所有函数的参数都是按值传递的(包括原始值和引用值)。  

## 确定类型
`typeof`操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一
个变量是否为字符串、数值、布尔值或`undefined`的最好方式。如果值是对象或`null`，那么 typeof返回`object`。   

`instanceof` 操作符:
```javascript
    result = variable instanceof constructor;
```  
如果变量是给定引用类型(由原型链决定)的实例,则`instanceof`操作符返回`true`。  
> 注意：
> 按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和
Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，
因为原始值不是对象。typeof 操作符在用于检测函数时也会返回"function"。当在 Safari（直到 Safari 5）和 Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof
也会返回"function"。ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在
typeof 检测时返回"function"。因为上述浏览器中的正则表达式实现了这个方法，所
以 typeof 对正则表达式也返回"function"。在 IE 和 Firefox 中，typeof 对正则表达式
返回"object"。  

# 4 执行上下文与作用域  
执行上下文(上下文)的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定
了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。   
&emsp;&emsp;全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象（第 12 章会详细介绍），因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。

>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。`ECMAScript`程序的执行流就是通过这个上下文栈进行控制的。      

上下文中的代码在执行的时候，会创建变量对象的一个`作用域链(scope chain)`。 这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象用作变量对象。活动对象最初只有一个定义变量:`arguments`(全局上下文中没有这个变量)。作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。
>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链
的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）   

>**内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的，有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。**   
>注意:函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。  

## 作用域链增强   
虽然执行上下文主要有全局上下文和函数上下文两种(eval()调用内部存在的第三种上下文),但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。  
+ `try/catch` 语句的`catch`块   
+ `with`语句  
这两种情况下，都会在作用域链前端添加一个变量对象。对于`wuth`语句来说，会向作用域链前端添加指定对象；对`catch`语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。  

## 变量声明   
1.使用`var`的函数作用域声明  
在使用`var`声明变量时,变量会被自动添加到最接近的上下文。
>在函数中,最接近的上下文就是函数的局部上下文。  
在`with`语句中，最接近的上下文也是函数上下文。  

如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。  

## 使用`const`的常量声明   
使用`const`声明的变量必须同时初始化为某个值。   
> `const`声明只应用到顶级原语或者对象。**赋值为对象的`const`变量不能再被重新赋值为其他引用值,但对象的键则不受限制。**   

如果想让整个对象都不能修改，可以使用`Object.freeze()`。  

由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。  

## 标识符查找
>注意 标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。不过，JavaScript 引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不足道了。  

# 垃圾回收
&emsp;&emsp;垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。   

## 标记清理  
JavaScript 最常用的垃圾回收策略是**标记清理**(mark-and-sweep)。
>当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。    

给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。
>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内
存清理，销毁带标记的所有值并收回它们的内存。到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。    

## 引用计数  
另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一
个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。  
引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。比如:  
```javascript
function problem() { 
 let objectA = new Object(); 
 let objectB = new Object(); 
 objectA.someOtherObject = objectB; 
 objectB.anotherObject = objectA; 
}    
```  
**通过以下代码可以清除前面的例子中建立的循环引用：**
```javascript
let element = document.getElementById("some_element"); 
let myObject = new Object(); 
myObject.element = element; 
element.someObject = myObject; 
myObject.element = null; 
element.someObject = null; 

```
>警告 在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在 IE 中，window. CollectGarbage()方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用 window. opera.collect()也会启动垃圾回收程序。   

## 内存管理  
解除引用,这个建议最适合全局变量和全局对象的属性，局部变量在超出作用域后会被自动解除引用。不过要注意，解除对一个值的引用并不会导致相关内存会被回收。解除引用的关键在于确保相关的值已经不在是那个下文里了，因此在下次垃圾回收时会被回收。  
+ 1.通过`const`和`let`声明提升性能。  
+ 2.隐藏类和删除操作。  

## 内存泄漏  
+ 意外声明全局变量   
使用`JavaScript`闭包很容易在不知不觉间造成内存泄漏。eg:
```javascript
let outer = function() { 
 let name = 'Jake'; 
 return function() { 
    return name; 
 }; 
}; 
```
调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字符串），那可能就是个大问题了。  

## 静态分配与对象池   
一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运
行。如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。

# 思考
1.`javaScript`变量可以保存哪种类型的值？原始值包含哪几种数据类型？原始值和引用值有什么区别？
2.如何区分原始值类型？如何确定引用值类型？
3.执行上下文(作用域)有几种？如何理解`JavaScript`的执行上下文？
4.`let`,`const`,`var`有什么区别?  `const`声明的对象可以修改吗？如果不想让`const`声明的对象键改变，应该怎么做？   
5.垃圾回收的常用方法？`JavaScript` 最常用的垃圾回收策略是什么？`JavaScript` 的垃圾回收程序是什么样的？  
6.用引用计数策略进行垃圾回收有什么问题？什么是循环引用？如何解决循环引用？  
