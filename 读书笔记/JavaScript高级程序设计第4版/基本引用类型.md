 ## 一、拆阅章节(第五章)  
 ### 基本引用类型  
 引用值(或者对象)是某个特定**引用类型**的实例。  

 >在ECMAScript中,引用类型是把数据和功能组织到一起的结构，经常被人错误地称作"类"。虽然从技术上讲`JavaScript`是一门面向对象语言，但`ECMAScript`缺少传统的面向对象编程语言所具备的某些基本结构，包括**类**和**接口。引用类型有时候也被称为**对象定义**,因为它们描述了自己的对象应有的属性和方法。

 > 引用类型虽然有点像类，但跟类并不是一个概念。   

 对象被认为是某个特定引用类型的**实例**。新对象通过使用`new`操作符后跟一个`构造函数(constructor)`来创建。构造函数就是用来创建新对象的函:     
 `let now = new Date();`  
`ECMAScript`提供了很多像`Date`这样的原生引用类型，帮助开发者实现常见的任务。

### Date 
`ECMAScript`的`Date`类型参考了`java`早期版本中的`java.util.Date`。为此,`Date`类型将日期保存为**自协调世界时间(UTC,Universal )**1970年1月1日午夜(零时)至今所经过的毫秒数。使用这种存储格式，`Date`类型可以精确表示1970年1月1日之前及之后285616年的日期。  
要创建日期对象,就使用`new`操作符来调用`Date`构造函数:   
```javascript
let now = new Date();
```  
在不给`Date`构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。  
ECMAScript为此提供了两个辅助方法：`Date.parse()`和 `Date.UTC()`。  

`Date.parse()`方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。`ECMA-262`第5版定义了`Date.parse()`应该支持的日期格式。所有实现都必须支持下列日期格式:
+ "月/日/年",如"5/23/2019";
+ "月名 日,年",如"May 23,2019";
+ "周几 月名 日 年 时:分:秒 时区",如"Tue May 23 2019 00:00:00 GMT-0700"；
+  ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于
兼容 ES5 的实现）。  

比如,要创建一个表示"2019年5月23日"的日期对象，可以使用以下代码:

```javascript
let someDate = new Date(Date.parse("May 23, 2019"));   
```   
如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面
那行代码是等价的：
```javascript
let someDate = new Date("May 23, 2019"); 
```  
这两行代码得到的日期对象相同。  

>注意:不同的浏览器对 Date 类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期，因此有些浏览器会将"January 32, 2019"解释为"February 1, 2019"。Opera 则会插入当前月的当前日，返回"January 当前日, 2019"。就是说，如果是在 9 月 21 日运行代码，会返回"January 21, 2019"。  

`Date.UTC()`方法也返回日期的毫秒表示,但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：  
```javascript
// GMT 时间 2000 年 1 月 1 日零点
let y2k = new Date(Date.UTC(2000, 0)); 
// GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); 
```   
与 Date.parse()一样，Date.UTC()也会被 Date 构造函数隐式调用，但有一个区别：这种情况
下创建的是本地日期，不是 GMT 日期。不过 Date 构造函数跟 Date.UTC()接收的参数是一样的。因
此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。前面的例子也可以这样来写：
```javascript
// 本地时间 2000 年 1 月 1 日零点
let y2k = new Date(2000, 0); 
// 本地时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒
let allFives = new Date(2005, 4, 5, 17, 55, 55); 
```  
以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地时区的日期。  
ECMAScript 还提供了 `Date.now()`方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：   
```javascript
// 起始时间
let start = Date.now(); 
// 调用函数
doSomething(); 
// 结束时间
let stop = Date.now(), 
result = stop - start; 
```  
### 继承的方法  
与其他类型一样，Date类型重写了`toLocaleString()`、`toString()`和`valueOf()`方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的2019 年 2 月 1 日零点的示例（地区为"en-US"的 PST，即 Pacific Standard Time，太平洋标准时间）。  
```javascript
toLocaleString() - 2/1/2019 12:00:00 AM 
toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time) 
```      
现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着 toLocaleString()和 toString()可能只对调试有用，不能用于显示。  
Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：  
```javascript
let date1 = new Date(2019, 0, 1); // 2019 年 1 月 1 日
let date2 = new Date(2019, 1, 1); // 2019 年 2 月 1 日
console.log(date1 < date2); // true 
console.log(date1 > date2); // false 
```   
### 日期格式化方法  
Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：  
+ toDateString()显示日期中的周几、月、日、年（格式特定于实现）；
+ toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
+ toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
+ toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；
+ toUTCString()显示完整的 UTC 日期（格式特定于实现）。  
这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。    

> 注意: 还有一个方法叫 toGMTString()，这个方法跟 toUTCString()是一样的，目的是为了向后兼容。不过，规范建议新代码使用 toUTCString()。  

方法|说明  
---|----
**getTime()** | 返回日期的毫秒表示;与valueOf相同
setTIme(millisecounds) | 设置日期的毫秒表示，从而修改整个日期  
**getFullYear()** | 返回4位数年   
getUTCFullYear() | 返回UTC日期的4位数年   
setFullYear(year)  |   设置日期的年(yaer必须是4位数)
setUTCFullYear(year)  |  设置UTC日期的年(year必须是4位数)
**getMonth()**  |  返回日期的月(0表示1月，11表示12月)  
getUTCMonth()  |  返回UTC日期的月(0表示1月，11月表示12月)  
setMonth(month)  |  设置日期的月(Month为大于0的数值，大于11加年)  
setUTCMonth(month)  |  设置UTC日期的月(month为大于0的数值，大于11加年)  
**getDate()**  |  返回日期中的日(1~31)
getUTCDate()  |  返回UTC日期中的日(1~31)  
setDate(date)  |  设置日期中的日(如果date大于该月天数,则加月)  
setUTCDate(date)  |  设置UTC日期中的日(如果date大于该月天数，则加月)   
**getDay()**  |  返回日期中表示周几的数值(0表示周日，6表示周六)  
getUTCDay()  |  返回UTC日期中表示周几的数值(0表示周日，6表示周六)  
**getHours**  |  返回日期中的时(0~23)  
getUTCHours  | 返回日期中的时(0~23)  
setHours(hours)  |  设置日期中的时(如果hours大于23，则加日)  
setUTCHours(hours)  |  设置UTC日期中的时(如果hours大于23，则加日)  
**getMinutes()**  |  返回日期中的分(0~59)  
getUTCMinutes()  | 返回UTC日期中的分(0~59)  
setMinutes(minutes)  |  设置日期中的分(如果minutes大于59，则加时)  
setUTCMinutes(minutes)  |  设置UTC日期中的分(如果minutes大于59，则加时)  
**getSeconds()**   |  返回日期中的秒(0~59)  
**getUTCSeconds()**  |  返回UTC日期的秒(0~59)  
setSeconds(seconds)  | 设置日期中的秒(如果seconds大于59,则加分)  
setUTCSeconds(seconds) |  设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）
**getMilliseconds()** |  返回日期中的毫秒
getUTCMilliseconds() |  返回 UTC 日期中的毫秒
setMilliseconds(milliseconds)  |  设置日期中的毫秒
setUTCMilliseconds(milliseconds)  |  设置 UTC 日期中的毫秒
getTimezoneOffset()  |   返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异）  

### RegExp  

`ECMAScript`通过RegExp类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：  
```javascript
let expression = /pattern/flags;  
```  
这个正则表达式的`pattern`(模式)可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个flags(标记)，用于控制正则表达式的行为。下面给出了表示匹配模式的标记:
+ g:全局模式，表示查找字符的全部内容，而不是找到第一个匹配的内容就结束。  
+ i:不区分大小写，表示在查找匹配时忽略`pattern`和字符串的大小写。
+ m:多行模式，表示查找到一行文本末尾时会继续查找。
+ y:粘贴模式，表示只查找从`lastIndex`开始及之后的字符串。
+ u:`Unicode`模式，启用Unicode匹配。
+ s:`dotAll`模式，表示元字符.匹配任何字符(包括\n或\r)。  
使用不同模式和标记可以创建出各种正则表达式，比如：
// 匹配字符串中的所有"at" 
```javascript
let pattern1 = /at/g; 
```
// 匹配第一个"bat"或"cat"，忽略大小写
```javascript
let pattern2 = /[bc]at/i; 
```
// 匹配所有以"at"结尾的三字符组合，忽略大小写
```javascript
let pattern3 = /.at/gi; 
```
与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：
```javascript
( [ { \ ^ $ | ) ] } ? * + . 
```
元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：
// 匹配第一个"bat"或"cat"，忽略大小写
```javascript
let pattern1 = /[bc]at/i; 
```
// 匹配第一个"[bc]at"，忽略大小写
```javascript
let pattern2 = /\[bc\]at/i; 
```
// 匹配所有以"at"结尾的三字符组合，忽略大小写
```javascript
let pattern3 = /.at/gi; 
```
// 匹配所有".at"，忽略大小写
```javascript
let pattern4 = /\.at/gi;
```
前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：  

// 匹配第一个"bat"或"cat"，忽略大小写
```javascript
let pattern1 = /[bc]at/i; 
```
// 跟 pattern1 一样，只不过是用构造函数创建的
```javascript
let pattern2 = new RegExp("[bc]at", "i"); 
```
这里的 pattern1 和 pattern2 是等效的正则表达式。注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\\，在正则表达式字符串中则要写成\\\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串。  

字面量模式|对应的字符串
---|---
/\[bc\]at/ | "\\[bc\\]at"
/\.at/ | "\\.at"
/name\/age/ | "name\\/age"
/\d.\d{1,2}/ | "\\d.\\d{1,2}"
/\w\\hello\\123/ | "\\w\\\\hello\\\\123"  

此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：
```javascript
const re1 = /cat/g; 
console.log(re1); // "/cat/g" 
const re2 = new RegExp(re1); 
console.log(re2); // "/cat/g" 
const re3 = new RegExp(re1, "i"); 
console.log(re3); // "/cat/i" 
```    
### RegExp实例属性 
每个`RegExp`实例都有下列属性，提供有关模式的各方面信息。
+ global：布尔值，表示是否设置了 g 标记。
+ ignoreCase：布尔值，表示是否设置了 i 标记。
+  unicode：布尔值，表示是否设置了 u 标记。
+  sticky：布尔值，表示是否设置了 y 标记。
+  lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。
+  multiline：布尔值，表示是否设置了 m 标记。 
+  dotAll：布尔值，表示是否设置了 s 标记。  
+  source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。 
+   flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。  
通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含这些信息。下面是一个例子：
```javascript
let pattern1 = /\[bc\]at/i;
console.log(pattern1.global); // false 
console.log(pattern1.ignoreCase); // true 
console.log(pattern1.multiline); // false 
console.log(pattern1.lastIndex); // 0 
console.log(pattern1.source); // "\[bc\]at" 
console.log(pattern1.flags); // "i" 
```  
>通过字面量创建的和通过 RegExp 构造函数创建的，但两个模式的 source 和 flags 属性是相同的。source 和 flags 属性返回的是规范化之后可以在字面量中使用的形式。  

## 思考
`ECMAScript`日期对象，怎么获取当前日期的，年，月，日，时，分，秒?  
正则表达式怎么修改匹配模式，如是否区分大小写，是否开启全局匹配?


