## 一问题描述
打开一个app新页面的时候，如home页
会请求对应接口，渲染页面
此时切换页面到其它页面，无内容的新页面同样会请求接口渲染页面，但是此时回退到home页面(因为首页不是新打开，存在于任务栈中，此时不应该重复请求接口，重复渲染页面)，**此时页面又重新请求接口进行渲染页面**
## 虚拟任务栈分析
应用程序里存在任务栈，在web中不存在，所以叫虚拟任务栈
任务栈--加入--》首页空白(获取数据，渲染DOM)--加入--》商品列表空白(获取数据，渲染DOM)**此时之前的home页面依然存在在任务栈当中，只是被商品列表遮挡住了**--后退--》实际是把商品列表页面弹出任务栈（首页会重新展示，但是不应该重新获取数据渲染DOM）
## 解决方法
实现一个虚拟任务栈
借助vue提供的<keep-alive>组件
定义：<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。
保留组件状态，避免组件被重新渲染。

1.给`<router-view>`添加一个<keep-alive>此时所有通过router-view加载的页面组件都会被缓存
**产生问题：**回退页面之后不会重新获取数据渲染DOM，重新进入商品列表页面也不会重新请求数据
利用props include属性

## 问题描述
页面跳转滑动状态保存
当我们进入一个页面之后，滚动页面到某一位置，进入下一页面回退之后，页面没有保持在离开此页面时的位置（虚拟任务栈是可以的）
## 解决方法
页面滑动的状态保存  
+ 1.所有的组件中数据都会被保存下来
+ 2.需要在组件中创建一个变量(会被keepAlive保存起来)，通过这个变量来记录当前页面的滑动距离。
+ 3.当后退回该页面的时候，使用这个变量来改变当前页面的一个滑动距离。
利用当组件在`keep-alive`内被切换，它的`activated`和`deactivated`这两个生命周期钩子函数将会被对应执行。
#### 应该在什么时机去改变当前页面的滑动距离？
 activated(keepAlive组件被激活时调用) deactivated会在updated之后被调用可以在组件的activited方法中去指定页面滑动模块的滑动距离

 ## 异步组件
 异步组件动态组件切换时，数据重复请求问题
 解决办法:使用keepAlive包裹住异步组件

## 页面刷新提示错误
app端页面不可主动刷新
刷新页面，vueRouter中的params就会被重置
